{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JPortal2","text":"<p>From the docs of sqlc</p> <p>And lo, the Great One looked down upon the people and proclaimed: \u201cSQL is actually pretty great\u201d</p>"},{"location":"#compile-sql-to-type-safe-code-in-any-language","title":"Compile SQL to type-safe code, in any language","text":"<p>JPortal2 is the newest version of the JPortal SI-file based generator.</p>"},{"location":"#full-documentation","title":"Full Documentation","text":"<p>For full Documentation see here.</p>"},{"location":"#what-is-jportal2","title":"What is JPortal2?","text":"<p>JPortal2 generates fully type-safe idiomatic code from SQL.</p> <ul> <li>You write table definitions and SQL queries</li> <li>You run JPortal2 to generate code that presents type-safe interfaces to those queries</li> <li>You write application code that calls the methods JPortal2 generated.</li> </ul> <p>It's that easy. You don't have to write any boilerplate SQL querying code ever again. See the current list of supported programming languages and databases here: Generator Docs.</p>"},{"location":"#how-it-works","title":"How it Works","text":"<p>Simply put, JPortal2 (and JPortal before it) is a data-definition first code generator. To use it, you:</p> <ol> <li>Define database tables using a small, easy-to-understand Domain-Specific Language (DSL).</li> <li>You define the queries you want to expose for the table. Standard CRUD queries like SELECT, INSERT, UPDATE, DELETE and MERGE can be created for you.</li> <li>More complex queries can easily be defined using standard SQL. </li> </ol> <p>Once you have defined your tables, you run the JPortal2 generator, and specify the code you want generated.  </p> <p>JPortal2 can generate:  </p> <ol> <li>DDL for all the popular RDBMS systems (Postgres, MySQL, Oracle, SQLServer, DB/2 and others)  </li> <li>DAL (Data Access Layers) for most languages (C/C++, Java, C#, Python and others)  </li> <li>Code stubs that can be used in other generators to create Client/Server and other Applications  </li> <li>Anything else you want to generate off your database structure  </li> </ol> <p>JPortal2 has a number of built-in code generators written in Java, but also has built-in Freemarker support to allow you to easily add your own generators.</p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#docker","title":"Docker","text":"<p>First pull the docker image for the version of JPortal you want to use. You can browse to https://github.com/si-gen/jportal2 to look at the available versions.</p> <pre><code>echo Running JPortal2 from ${PWD}...\n\ndocker run --rm -v ${PWD}:/local ghcr.io/si-gen/jportal2:latest \\\n--inputdir=/local/sql/si \\\n--builtin-generator PostgresDDL:/local/generated_sources/generated_sql \\\n--template-generator SQLAlchemy:/local/generated_sources/python/jportal \\\n--download-template \"SQLAlchemy:https://github.com/SI-Gen/jportal2-generator-vanguard-sqlalchemy/archive/refs/tags/1.8.zip|stripBaseDir\"                      </code></pre>"},{"location":"#java","title":"Java","text":"<p>The Java JAR is hosted at https://ossindex.sonatype.org/component/pkg:maven/za.co.bbd/jportal2</p> <p>To use JPortal2 in your Maven based Java project, simply add the following to your POM: properties: <pre><code>&lt;properties&gt;    &lt;jportal2.version&gt;1.3.0&lt;/jportal2.version&gt;\n&lt;jportal2maven.version&gt;1.2.0&lt;/jportal2maven.version&gt;\n&lt;/properties&gt;\n</code></pre> dependencies: <pre><code>        &lt;dependency&gt;\n&lt;groupId&gt;za.co.bbd&lt;/groupId&gt;\n&lt;artifactId&gt;jportal2&lt;/artifactId&gt;\n&lt;version&gt;1.3.0&lt;/version&gt;\n&lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> and plugins: <pre><code>            &lt;plugin&gt;\n&lt;groupId&gt;za.co.bbd&lt;/groupId&gt;\n&lt;artifactId&gt;jportal2-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;${jportal2maven.version}&lt;/version&gt;\n&lt;configuration&gt;\n&lt;sourcePath&gt;${basedir}/src/main/sql/&lt;/sourcePath&gt;\n&lt;generators&gt;\n&lt;generator&gt;JavaJCCode:${basedir}/target/generated-sources/java/com/example/db&lt;/generator&gt;\n&lt;generator&gt;PostgresDDL:${basedir}/target/generated-sources/scripts/sql&lt;/generator&gt;\n&lt;/generators&gt;\n&lt;compilerFlags&gt;\n&lt;compilerFlag&gt;utilizeEnums&lt;/compilerFlag&gt;\n&lt;/compilerFlags&gt;\n&lt;!--                    &lt;additionalArguments&gt;&amp;#45;&amp;#45;template-generator JdbiSqlObjects:${basedir}/target/generated-sources/java/&lt;/additionalArguments&gt;--&gt;\n&lt;/configuration&gt;\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;za.co.bbd&lt;/groupId&gt;\n&lt;artifactId&gt;jportal2&lt;/artifactId&gt;\n&lt;version&gt;${jportal2.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n&lt;executions&gt;\n&lt;execution&gt;\n&lt;phase&gt;generate-sources&lt;/phase&gt;\n&lt;goals&gt;\n&lt;goal&gt;jportal&lt;/goal&gt;\n&lt;/goals&gt;\n&lt;/execution&gt;\n&lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre></p> <p>JPortal2 is the actual Data Access Layer (DAL) generator. jportal2-maven-plugin is a plugin for maven that will run the generator at build time.</p> <p>Create a file called todolist.si in the ${basedir}/src/main/sql/ directory (this is defined above in sourcePath tag)</p> <p>todolist.si <pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDoList\nID               SEQUENCE\nListName         CHAR(255)\nListType         SHORT (Private=1, Public=2)\nDescription      CHAR\nLastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\nID\n\n//Simple CRUD queries are available out of the box with JPortal2\nPROC Insert Returning\nPROC Update\nPROC SelectOne\nPROC DeleteOne\n\n//More complex custom queries can be defined using standard SQL\nPROC SelectListNameAndListTypeAsString\nINPUT\nID          =\nOUTPUT\nListName    =\nListType    CHAR\nSQLCODE\nSELECT\nListName,\nCASE\nWHEN ListType = 1 THEN 'Private'\nWHEN ListType = 2 THEN 'Public'\nEND\nFROM\nTodoList\nWHERE\nID = :ID\nENDCODE\n\n//Dynamic queries can be done with the ampersand below\n//REMEMBER!!! Dynamic SQL is open to SQL injection! So use with care and make sure to sanitize inputs!\n//Dynamic SQL is a last resort escape hatch, not the first tool to reach for!!\n//In the DAL class created for the below query, a property called MyDynamicWhereClause will be created\n//This will allow you to pass through the remainder of the where clause as a string.\nPROC SelectWithDynamicQuery\nINPUT\nListName    =\nOUTPUT\nID               SEQUENCE\nListName         CHAR(255)\nListType         SHORT (Private=1, Public=2)\nDescription      CHAR\nLastUpdated      TIMESTAMP\nSQLCODE\nSELECT\nID\n,ListName\n,ListType\n,Description\n,LastUpdated\nFROM\nToDoList\nWHERE\nListName = :ListName\nAND &amp;MyDynamicWhereClause\nENDCODE\n</code></pre></p> <p>Now create a file called todo_items.si in the same directory (${basedir}/src/main/sql/) todo_items.si <pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDo_Item\nID               SEQUENCE\nTodoList_ID      INT     //This is a foreign key to the ToDoList table\nItemName         CHAR(255)\nItemDescription  CLOB\nLastUpdated      TIMESTAMP\n\n//This define ID as the Primary Key\nKEY PKEY PRIMARY\nID\n\nPROC Insert Returning\nPROC Update\nPROC SelectOne\nPROC DeleteOne\n\n//The SelectBy function automatically creates\n//a SELECT query using the given fields as the\n//WHERE clause\nPROC SelectBy TodoList_ID\nOUTPUT\nID                  =\nItemName            =\nItemDescription     =\nLastUpdated         =\n</code></pre></p> <p>Now compile your maven project. If all went well, you should see 2 files inside the directory ${basedir}/target/generated-sources/java/com/example/db.</p>"},{"location":"faq/","title":"F.A.Q.","text":""},{"location":"faq/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"faq/#1-how-do-i-specify-decimal-as-the-column-type-in-an-si-file","title":"1. How do I specify Decimal as the column type in an SI file?","text":"<p>Use the MONEY column-type. See ColumnTypes for a full list of column types supported by JPortal.</p>"},{"location":"faq/#2-what-does-the-equals-sign-mean-in-an-si","title":"2. What does the equals sign (<code>=</code>) mean in an SI?","text":"<p>The equals sign means <code>Use the column type defined in the above Table section, for the column of the same name</code>. See the section on The <code>=</code> (equals sign) for a more in depth explanation.</p>"},{"location":"history/","title":"History","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#jportal","title":"JPortal","text":"<p>JPortal was originally developed in the early 1990's by Vincent Risi (https://github.com/VincentRisi) as a standardised way to generate a Data Access Layer (DAL) for multiple databases and target languages. SI Files allow the definition of a SQL table with columns, as well as SQL Queries to be run against the table. It then allows the generation of a DAL in a number of languages. Being developed in the 90's, the first languages that were supported, were Java, C++, C and Visual Basic. Original database support was for Oracle.</p> <p>Over the years the tool has grown into a suite of tools to include generators DAL's, RPC client and server generators and for a number of languages including C# and Python, and database support for Oracle, SQL Server, MySQL, PostgreSQL, DB2 and SQLite.</p>"},{"location":"history/#jportal2","title":"JPortal2","text":"<p>The original JPortal grew organically, and while over the years the capabilities have expanded, lots of it was not envisioned originally. As a result, some of the code has become difficult to maintain. JPortal2 is an attempt to clean up the code bit-by-bit, and also start adding unittests and other features that are required in modern libraries.</p>"},{"location":"history/#original-code","title":"Original Code","text":"<p>The original JPortal code can be found at https://github.com/VincentRisi. An updated version with some bug-fixes can be found at https://github.com/dieterrosch. However, this repo (https://github.com/SI-Gen) is the only actively maintained repository. </p>"},{"location":"Contributing/Contribution/","title":"WORKFLOW","text":"<p>The workflow is based off the git-repo SI-Gen/github-actions-maven-release. The workflow will provide a release to nexus and then prep the pom for the next development release based on the input provided</p> <p>** Note that the release version will be based off the current version in the pom. The pom MUST have a <code>-SNAPSHOT</code>. <pre><code>&lt;version&gt;1.5.6-SNAPSHOT&lt;/version&gt;\n</code></pre></p>"},{"location":"Contributing/Contribution/#workflow-process","title":"WORKFLOW Process","text":"<ol> <li>When ready for a release, head over to the github actions tab </li> <li>You should see the <code>Release</code>  workflow under the work-flows list</li> <li>The work flow is initiated manually on master. Provide a description of the release (not-required)  and what the next version of the release will be (patch, minor, major).</li> <li>Initiate Workflow and let the magic happen.</li> </ol>"},{"location":"Contributing/Contribution/#contributions","title":"Contributions","text":"<ul> <li>GitHub Actions</li> <li>anothrNick/github-tag-action</li> <li>qcastel/github-actions-maven-release</li> <li>WyriHaximus/github-action-get-previous-tag</li> <li>mikepenz/release-changelog-builder-action</li> <li>svenstaro/upload-release-action</li> </ul>"},{"location":"Howto/checking-if-rows-exist/","title":"Checking if a record exists","text":"<p>To check if a row with a specific primary key exists, we use the Exists proc.</p> <pre>\n<code>\nDATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDoList\n   ID               SEQUENCE\n   ListName         CHAR(255)\n   ListType         SHORT (Private=1, Public=2)\n   Description      CHAR(255)\n   LastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\n    ID\n\nPROC Exists\n</code>\n</pre>"},{"location":"Howto/checking-if-rows-exist/#exist","title":"Exist","text":"<p>Checks if a record with a specific primary key exists.</p> <pre><code>Exists\n</code></pre> <p>Exists will check if a record with a specific primary key exists.</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode <pre><code>@dataclass\nclass DB_ToDoListExists:\n    #Outputs\n    noOf: int\n\n    @classmethod\n    def get_statement(cls\n                     , ID: int\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \" OUTPUT (noOf)\"\n            tail = \" RETURNING noOf\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDoList.Exists */\"\n                        f\"select count(*) noOf from ToDoList_App.ToDoList\"\n                        f\" where ID = :ID\")\n\n        text_statement = statement.columns(noOf=sa.types.Integer,\n                                      )\n        text_statement = text_statement.bindparams(ID=ID,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ID: int\n                     ) -&gt; Optional['DB_ToDoListExists']:\n        params = process_bind_params(session, [sa.types.Integer,\n                                        ], [ID,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_ToDoListExists, session, [sa.types.Integer,\n                                        ], rec)\n\n        return None\n</code></pre> <pre><code>public boolean exists() throws SQLException\n{\nString statement = \"/* PROC BooksAndAuthors.ToDoList.Exists */\"\n+ \"select count(*) noOf from BooksAndAuthors.ToDoList\"\n+ \" where ID = ?\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.setInt(1, id);\nResultSet result = prep.executeQuery();\nif (!result.next())\n{\nresult.close();\nprep.close();\nreturn false;\n}\nnoOf =  result.getInt(1);\nresult.close();\nprep.close();\nreturn true;\n}\n</code></pre>"},{"location":"Howto/counting-rows/","title":"Counting rows","text":"<p>Counting records in a table is easy.</p> <pre>\n<code>\nDATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDoList\n   ID               SEQUENCE\n   ListName         CHAR(255)\n   ListType         SHORT (Private=1, Public=2)\n   Description      CHAR(255)\n   LastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\n    ID\n\nPROC Count\n</code>\n</pre>"},{"location":"Howto/counting-rows/#count","title":"Count","text":"<p>Counts the number of records in a table.</p> <pre><code>Count\n</code></pre> <p>Count will count the number of records in a table.</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode <pre><code>@dataclass\nclass DB_ToDoListCount:\n    #Outputs\n    noOf: int\n\n    @classmethod\n    def get_statement(cls\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \" OUTPUT (noOf)\"\n            tail = \" RETURNING noOf\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDoList.Count */\"\n                        f\"select count(*) noOf from ToDoList_App.ToDoList\")\n\n        text_statement = statement.columns(noOf=sa.types.Integer,\n                                      )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session) -&gt; Optional['DB_ToDoListCount']:\n        res = session.execute(cls.get_statement())\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_ToDoListCount, session, [sa.types.Integer,\n                                        ], rec)\n\n        return None\n</code></pre> <pre><code>  public boolean count() throws SQLException\n{\nString statement = \"/* PROC BooksAndAuthors.ToDoList.Count */\"\n+ \"select count(*) noOf from BooksAndAuthors.ToDoList\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nResultSet result = prep.executeQuery();\nif (!result.next())\n{\nresult.close();\nprep.close();\nreturn false;\n}\nnoOf =  result.getInt(1);\nresult.close();\nprep.close();\nreturn true;\n}\n</code></pre>"},{"location":"Howto/custom-procs/","title":"Custom procs","text":"<p>Write a custom proc if the built-in procs don't give you the power or flexibility you need.</p> <pre><code>PROC &lt;proc_name&gt;\n[ (standard) ]\n[ ** &lt;comment&gt; ]*\n[ OPTIONS &lt;option_string&gt;+ ]\n[INPUT\n    (&lt;InputField&gt; &lt;InputFieldType&gt;)+\n]\n[INOUT\n    (&lt;InoutField&gt; &lt;InoutFieldType&gt;)+\n]\n[OUTPUT\n    (&lt;OutputField&gt; &lt;OutputFieldType&gt;)+\n]\n[[SQL]CODE]\n&lt;Lines of SQL code&gt;+\n[ENDCODE]\n</code></pre> <p><code>&lt;proc_name&gt;</code> specifies the name of the proc. <code>(standard)</code> is a keyword which indicates to JPortal2 that the fields returned by the query, will include all the fields of the table. The <code>(standard)</code> clause is mostly used with some older built-in generators for typed languages like C#, Java or C++. Its use is largely supersedes in most of the newer generators and the template generators, since one can get exactly the same functionality by using SelectBy and not specifying  <code>OUTPUT</code> clause. <code>&lt;comment&gt;</code> is a comment that will get added to the generated code. Not all generators support comments. <code>&lt;option_string&gt;</code> is a list of string options that can be passed to the generators. The options are generator specified. If you want to use the a specific generator's options, the generator's instructions will tell you what to pass into <code>&lt;option_string&gt;</code>. The <code>INPUT</code> section defines the input fields into the proc. The <code>INOUT</code> section defines fields that are input and output fields into the proc. You can also put the fieldname into both the INPUT and OUTPUT section for the same effect. The <code>OUTPUT</code> section defines the output fields into the proc. The <code>SQLCODE</code> and <code>ENDCODE</code> keywords specify the beginning and end of your custom SQL.</p> books.si<pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA BooksAndAuthors\n\nTABLE Books\nID               SEQUENCE\nAuthorID         INT\nTitle            CHAR(255)\nPublishDate      DATE\nLastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\nID\n\nPROC SelectBookAndAuthorDetails ** This proc selects books and their authors for titles like :TitleLike. ** You can pass in a wildcard into TitleLike eg TitleLike = 'ABC%'\nINPUT\nTitleLike   CHAR(255)\nOUTPUT\nBio             CHAR(255)\nTitle           =\nPublishDate     =\nLastUpdated     =\nSQLCODE\nSELECT\na.Bio,\nb.Title,\nb.PublishDate,\nb.LastUpdated\nFROM\nAuthors a\nINNER JOIN\nBooks b\nON a.ID = b.AuthorID\nWHERE\nb.Title LIKE :TitleLike\nENDCODE\n</code></pre> <p>The generated code will look like below:  </p> --template-generator SQLAlchemy--builtin-generator JavaJCCode <pre><code>    @dataclass\n    class DB_BooksSelectBookAndAuthorDetails:\n    #Outputs\n    Bio: str\n    Title: str\n    PublishDate: datetime\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     , TitleLike: str\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \" OUTPUT (Bio,Title,PublishDate,LastUpdated)\"\n            tail = \" RETURNING Bio Title PublishDate LastUpdated\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC BooksAndAuthors.Books.SelectBookAndAuthorDetails */\"\n                        f\"SELECT \"\n                        f\"a.Bio, \"\n                        f\"b.Title, \"\n                        f\"b.PublishDate, \"\n                        f\"b.LastUpdated \"\n                        f\"FROM \"\n                        f\"Authors a \"\n                        f\"INNER JOIN \"\n                        f\"Books b \"\n                        f\"ON a.ID = b.AuthorID \"\n                        f\"WHERE \"\n                        f\"b.Title LIKE :TitleLike \")\n\n        text_statement = statement.columns(Bio=db_types.NonNullableString,\n                                      Title=db_types.NonNullableString,\n                                      PublishDate=sa.types.DateTime,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        text_statement = text_statement.bindparams(TitleLike=TitleLike,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, TitleLike: str\n                     ) -&gt; List['DB_BooksSelectBookAndAuthorDetails']:\n        params = process_bind_params(session, [db_types.NonNullableString,\n                                        ], [TitleLike,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        recs = res.fetchall()\n        return process_result_recs(DB_BooksSelectBookAndAuthorDetails, session, [db_types.NonNullableString,\n                                        db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        sa.types.DateTime,\n                                        ], recs)\n</code></pre> BooksSelectBookAndAuthorDetails.java<pre><code>package com.example.db;\n\nimport bbd.jportal2.util.*;\nimport java.sql.*;\nimport java.util.*;\nimport java.math.*;\n\n/**\n * This proc selects books and their authors for titles like :TitleLike. \n * You can pass in a wildcard into TitleLike eg TitleLike = 'ABC%'\n */\npublic class BooksSelectBookAndAuthorDetails extends BooksSelectBookAndAuthorDetailsStruct\n{\nprivate static final long serialVersionUID = 1L;\nConnector connector;\nConnection connection;\npublic BooksSelectBookAndAuthorDetails()\n{\nsuper();\n}\npublic void setConnector(Connector conn)\n{\nthis.connector = conn;\nconnection = connector.connection;\n}\npublic BooksSelectBookAndAuthorDetails(Connector connector)\n{\nsuper();\nthis.connector = connector;\nconnection = connector.connection;\n}\n/**\n     * This proc selects books and their authors for titles like :TitleLike. \n     * You can pass in a wildcard into TitleLike eg TitleLike = 'ABC%'\n     * Returns any number of records.\n     * @return result set of records found\n     * @exception SQLException is passed through\n     */\npublic Query selectBookAndAuthorDetails() throws SQLException\n{\nString statement =\n\"/* PROC BooksAndAuthors.Books.SelectBookAndAuthorDetails */\"\n+ \"SELECT \"\n+ \"a.Bio, \"\n+ \"b.Title, \"\n+ \"b.PublishDate, \"\n+ \"b.LastUpdated \"\n+ \"FROM \"\n+ \"Authors a \"\n+ \"INNER JOIN \"\n+ \"Books b \"\n+ \"ON a.ID = b.AuthorID \"\n+ \"WHERE \"\n+ \"b.Title LIKE ? \"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.setString(1, titleLike);\nResultSet result = prep.executeQuery();\nQuery query = new Query(prep, result);\nreturn query;\n}\n/**\n     * Returns the next record in a result set.\n     * @param query The result set for the query.\n     * @return true while records are found.\n     * @exception SQLException is passed through\n     */\npublic boolean selectBookAndAuthorDetails(Query query) throws SQLException\n{\nif (!query.result.next())\n{\nquery.close();\nreturn false;\n}\nResultSet result = query.result;\nbio =  result.getString(1);\ntitle =  result.getString(2);\npublishDate =  result.getDate(3);\nlastUpdated =  result.getTimestamp(4);\nreturn true;\n}\n/**\n     * Returns all the records in a result set as array of BooksSelectBookAndAuthorDetails.\n     * @return array of BooksSelectBookAndAuthorDetails.\n     * @exception SQLException is passed through\n     */\npublic BooksSelectBookAndAuthorDetails[] selectBookAndAuthorDetailsLoad() throws SQLException\n{\nVector&lt;BooksSelectBookAndAuthorDetails&gt; recs = new Vector&lt;&gt;();\nQuery query = selectBookAndAuthorDetails();\nwhile (selectBookAndAuthorDetails(query) == true)\n{\nBooksSelectBookAndAuthorDetails rec = new BooksSelectBookAndAuthorDetails();\nrec.bio = bio;\nrec.title = title;\nrec.publishDate = publishDate;\nrec.lastUpdated = lastUpdated;\nrecs.addElement(rec);\n}\nBooksSelectBookAndAuthorDetails[] result = new BooksSelectBookAndAuthorDetails[recs.size()];\nfor (int i=0; i&lt;recs.size();i++)\nresult[i] = recs.elementAt(i);\nreturn result;\n}\n/**\n     * Returns any number of records.\n     * @return result set of records found\n     * @param titleLike input.\n     * @exception SQLException is passed through\n     */\npublic Query selectBookAndAuthorDetails(\nString titleLike\n) throws SQLException\n{\nthis.titleLike = titleLike;\nreturn selectBookAndAuthorDetails();\n}\n}\n</code></pre>"},{"location":"Howto/deleting-rows/","title":"Deleting rows","text":""},{"location":"Howto/deleting-rows/#built-in-procs","title":"Built-In Procs","text":"<p>JPortal ships with a number of built-in procs to allow easy deleting of records in a table.</p> <pre>\n<code>\nDATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDoList\n   ID               SEQUENCE\n   ListName         CHAR(255)\n   ListType         SHORT (Private=1, Public=2)\n   Description      CHAR(255)\n   LastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\n    ID\n\n//Simple CRUD queries are available out of the box with JPortal2\nPROC DeleteOne\nPROC DeleteBy ListName ListType\nPROC DeleteAll\n\n</code>\n</pre>"},{"location":"Howto/deleting-rows/#deleteone","title":"DeleteOne","text":"<p>Deletes an existing record by primary key.</p> <pre><code>DeleteOne\n[(standard)]\n</code></pre> <p>DeleteOne will delete an existing record in a table, by primary key. If no primary key is specified on the table, JPortal2 will issue a warning at compile time.</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode <pre><code>@dataclass\nclass DB_ToDoListDeleteOne:\n\n    @classmethod\n    def get_statement(cls\n                     , ID: int\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \"\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDoList.DeleteOne */\"\n                        f\"delete from ToDoList_App.ToDoList\"\n                        f\" where ID = :ID\")\n\n        text_statement = statement.columns()\n        text_statement = text_statement.bindparams(ID=ID,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ID: int\n                     ) -&gt; None:\n        params = process_bind_params(session, [sa.types.Integer,\n                                        ], [ID,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        res.close()\n</code></pre> <pre><code>public void deleteOne() throws SQLException\n{\nString statement = \"/* PROC BooksAndAuthors.ToDoList.DeleteOne */\"\n+ \"delete from BooksAndAuthors.ToDoList\"\n+ \" where ID = ?\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.setInt(1, id);\nprep.executeUpdate();\nprep.close();\n}\n</code></pre>"},{"location":"Howto/deleting-rows/#deleteby","title":"DeleteBy","text":"<p>Deletes record by user specified keys</p> <pre><code>DeleteBy &lt;DeleteKeyColumn&gt;+\n</code></pre> <p>DeleteBy will delete the records of a table that are specified by the keys specified by <code>DeleteKeyColumn</code>'s.  </p> --template-generator SQLAlchemy <pre><code>\n</code></pre>"},{"location":"Howto/deleting-rows/#deleteall","title":"DeleteAll","text":"<p>Deletes all existing records in table.</p> <pre><code>DeleteAll \n</code></pre> <p>DeleteAll will delete all existing records in a table.  </p> --template-generator SQLAlchemy--builtin-generator JavaJCCode <pre><code>@dataclass\nclass DB_ToDoListDeleteAll:\n    @classmethod\n    def get_statement(cls\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \"\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDoList.DeleteAll */\"\n                        f\"delete from ToDoList_App.ToDoList\")\n\n        text_statement = statement.columns()\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session) -&gt; None:\n        res = session.execute(cls.get_statement())\n        res.close()\n</code></pre> <pre><code>public static void deleteAll(Connector connector) throws SQLException\n{\nString statement =\n\"/* PROC BooksAndAuthors.ToDoList.DeleteAll */\"\n+\"delete from BooksAndAuthors.ToDoList\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.executeUpdate();\nprep.close();\n}\n</code></pre>"},{"location":"Howto/dynamic-sql/","title":"Dynamic SQL","text":"<p>Dynamic SQL allows you to do things that simply aren't possible with normal parameterized SQL, but it comes with risk.</p> <p>Danger</p> <p>While Dynamic SQL is very powerful, it is also very dangerous, because it opens you up to SQL Injection Attacks. You should try to avoid using dynamic SQL as far possible. If you are forced to use is, make sure to guard against SQL injection by either coding against it, or using a library that helps with that.</p> <p>To write a dynamic SQL query, write a proc like you would normally do, and at the point where you want to inject the dynamic portion, use <code>&amp;parameter_name(&lt;length&gt;)</code>. See below for an example.</p> todo_item.si<pre><code>//Dynamic queries can be done with the ampersand below\n//REMEMBER!!! Dynamic SQL is open to SQL injection! So use with care and make sure to sanitize inputs!\n//Dynamic SQL is a last resort escape hatch, not the first tool to reach for!!\n//In the DAL class created for the below query, a property called ItemNamesList will be created\n//This will allow you to pass through the remainder of the where clause as a string.\nPROC SelectWithDynamicQuery\nINPUT\nID              =\nOUTPUT\nItemName        =\nItemDescription =\nLastUpdated     =\nSQLCODE\nSELECT\nItemName,\nItemDescription,\nLastUpdated\nFROM\nToDoList_App.ToDo_Item i\nWHERE\ni.ID = :ID\nAND\nItemName IN (&amp;ItemNamesList(1024))\nENDCODE\n</code></pre> <p>The generated code will look like below:</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode ToDo_Item.py<pre><code>@dataclass\nclass DB_ToDo_ItemSelectWithDynamicQuery:\n    #Outputs\n    ItemName: str\n    ItemDescription: str\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     , ID: int\n                     , ItemNamesList: str) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \" OUTPUT (ItemName,ItemDescription,LastUpdated)\"\n            tail = \" RETURNING ItemName ItemDescription LastUpdated\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDo_Item.SelectWithDynamicQuery */\"\n                        f\"SELECT \"\n                        f\"ItemName, \"\n                        f\"ItemDescription, \"\n                        f\"LastUpdated \"\n                        f\"FROM \"\n                        f\"ToDoList_App.ToDo_Item i \"\n                        f\"WHERE \"\n                        f\"i.ID = :ID \"\n                        f\"AND \"\n                        f\"ItemName IN ( \"\nf\"{ItemNamesList}\" # (1)\nf\") \")\n\n        text_statement = statement.columns(ItemName=db_types.NonNullableString,\n                                      ItemDescription=sa.types.Text,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        text_statement = text_statement.bindparams(ID=ID,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ID: int\n\n                     , ItemNamesList: str) -&gt; List['DB_ToDo_ItemSelectWithDynamicQuery']:\n        params = process_bind_params(session, [sa.types.Integer,\n                                        db_types.NonNullableString,], [ID,\n                                        ItemNamesList,])\n        res = session.execute(cls.get_statement(*params))\n        recs = res.fetchall()\n        return process_result_recs(DB_ToDo_ItemSelectWithDynamicQuery, session, [db_types.NonNullableString,\n                                        sa.types.Text,\n                                        sa.types.DateTime,\n                                        ], recs)\n</code></pre> <ol> <li>We use python string interpolation to inject the string.</li> </ol> BooksSelectBookAndAuthorDetails.java<pre><code>package com.example.db;\n\nimport bbd.jportal2.util.*;\nimport java.sql.*;\nimport java.util.*;\nimport java.math.*;\n\n/**\n */\npublic class ToDo_ItemSelectWithDynamicQuery extends ToDo_ItemSelectWithDynamicQueryStruct\n{\nprivate static final long serialVersionUID = 1L;\nConnector connector;\nConnection connection;\npublic ToDo_ItemSelectWithDynamicQuery()\n{\nsuper();\n}\npublic void setConnector(Connector conn)\n{\nthis.connector = conn;\nconnection = connector.connection;\n}\npublic ToDo_ItemSelectWithDynamicQuery(Connector connector)\n{\nsuper();\nthis.connector = connector;\nconnection = connector.connection;\n}\n/**\n       * Returns any number of records.\n       * @return result set of records found\n       * @exception SQLException is passed through\n       */\npublic Query selectWithDynamicQuery() throws SQLException\n{\nString statement = \"/* PROC BooksAndAuthors.ToDo_Item.SelectWithDynamicQuery */\"\n+ \"SELECT \"\n+ \"ItemName, \"\n+ \"ItemDescription, \"\n+ \"LastUpdated \"\n+ \"FROM \"\n+ \"ToDoList_App.ToDo_Item i \"\n+ \"WHERE \"\n+ \"i.ID = ? \"\n+ \"AND \"\n+ \"ItemName IN ( \"\n+  {ItemNamesList} // (1)\n+ \" \"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.setInt(1, id);\nResultSet result = prep.executeQuery();\nQuery query = new Query(prep, result);\nreturn query;\n}\n/**\n       * Returns the next record in a result set.\n       * @param query The result set for the query.\n       * @return true while records are found.\n       * @exception SQLException is passed through\n       */\npublic boolean selectWithDynamicQuery(Query query) throws SQLException\n{\nif (!query.result.next())\n{\nquery.close();\nreturn false;\n}\nResultSet result = query.result;\nitemName =  result.getString(1);\nitemDescription =  result.getString(2);\nlastUpdated =  result.getTimestamp(3);\nreturn true;\n}\n/**\n       * Returns all the records in a result set as array of ToDo_ItemSelectWithDynamicQuery.\n       * @return array of ToDo_ItemSelectWithDynamicQuery.\n       * @exception SQLException is passed through\n       */\npublic ToDo_ItemSelectWithDynamicQuery[] selectWithDynamicQueryLoad() throws SQLException\n{\nVector&lt;ToDo_ItemSelectWithDynamicQuery&gt; recs = new Vector&lt;&gt;();\nQuery query = selectWithDynamicQuery();\nwhile (selectWithDynamicQuery(query) == true)\n{\nToDo_ItemSelectWithDynamicQuery rec = new ToDo_ItemSelectWithDynamicQuery();\nrec.itemName = itemName;\nrec.itemDescription = itemDescription;\nrec.lastUpdated = lastUpdated;\nrecs.addElement(rec);\n}\nToDo_ItemSelectWithDynamicQuery[] result = new ToDo_ItemSelectWithDynamicQuery[recs.size()];\nfor (int i=0; i&lt;recs.size();i++)\nresult[i] = recs.elementAt(i); return result;\n}\n/**\n       * Returns any number of records.\n       * @return result set of records found\n       * @param id input.\n       * @param SelectWithDynamicQuery dynamic input.\n       * @exception SQLException is passed through\n       */\npublic Query selectWithDynamicQuery(\nInteger id\n, String ItemNamesList\n) throws SQLException\n{\nthis.id = id;\nthis.ItemNamesList = ItemNamesList;\nreturn selectWithDynamicQuery();\n}\n}\n</code></pre> <ol> <li>We simply append the string to inject the query.</li> </ol>"},{"location":"Howto/inserting-rows/","title":"Inserting rows","text":""},{"location":"Howto/inserting-rows/#built-in-procs","title":"Built-In Procs","text":"<p>JPortal ships with a number of built-in procs to allow easy inserting of data into a database.</p> <p>Let assume the following table structure in our SI, with various procs defined to insert records:</p> <pre>\n<code>\nDATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDoList\n   ID               SEQUENCE\n   ListName         CHAR(255)\n   ListType         SHORT (Private=1, Public=2)\n   Description      CHAR(255)\n   LastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\n    ID\n\nPROC Insert\nPROC Insert Returning\nPROC BulkInsert\n</code>\n</pre> <p>Let's work through the above.</p>"},{"location":"Howto/inserting-rows/#insert","title":"Insert","text":"<p>Insert a new record.</p> <pre><code>Insert  \n[ RETURNING ]\n</code></pre> <p>Insert will insert a record into a table. Adding the RETURNING clause will cause JPortal2 to return the inserted primary key. This is useful when using database sequences.</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode InsertInsert Returning <pre><code>@dataclass\nclass DB_ToDoListInsert:\n    # Enum for ListType field\n    class ListTypeEnum(enum.Enum):\n        Private = 1\n        Public = 2\n\n        @classmethod\n        def process_result_value_cls(cls, value, dialect):\n            return DB_ToDoListInsert.ListTypeEnum(value)\n\n\n\n\n    @classmethod\n    def get_statement(cls\n                     , ListName: str\n                     , ListType: ListTypeEnum\n                     , Description: str\n                     , LastUpdated: datetime\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \"\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDoList.Insert */\"\n                        f\"insert into ToDoList_App.ToDoList (\"\n                        f\"  ListName,\"\n                        f\"  ListType,\"\n                        f\"  Description,\"\n                        f\"  LastUpdated\"\n                        f\" ) \"\n                        f\" values (\"\n                        f\"  :ListName,\"\n                        f\"  :ListType,\"\n                        f\"  :Description,\"\n                        f\"  :LastUpdated\"\n                        f\" )\")\n\n        text_statement = statement.columns()\n        text_statement = text_statement.bindparams(ListName=ListName,\n                                         ListType=ListType,\n                                         Description=Description,\n                                         LastUpdated=LastUpdated,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ListName: str\n                     , ListType: ListTypeEnum\n                     , Description: str\n                     , LastUpdated: datetime\n                     ) -&gt; None:\n        params = process_bind_params(session, [db_types.NonNullableString,\n                                        sa.types.SmallInteger,\n                                        db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        ], [ListName,\n                                        ListType.value if isinstance(ListType, enum.Enum) else ListType,\n                                        Description,\n                                        LastUpdated,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        res.close()\n</code></pre> <pre><code>@dataclass\nclass DB_ToDoListInsertReturning:\n    # Enum for ListType field\n    class ListTypeEnum(enum.Enum):\n        Private = 1\n        Public = 2\n\n        @classmethod\n        def process_result_value_cls(cls, value, dialect):\n            return DB_ToDoListInsertReturning.ListTypeEnum(value)\n\n\n    #Outputs\n    ID: int\n\n    @classmethod\n    def get_statement(cls\n                     , ListName: str\n                     , ListType: ListTypeEnum\n                     , Description: str\n                     , LastUpdated: datetime\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\ntail = \" RETURNING ID\" # (1)!\n#session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDoList.Insert */\"\n                        f\"insert into ToDoList_App.ToDoList (\"\n                        f\"  ID,\"\n                        f\"  ListName,\"\n                        f\"  ListType,\"\n                        f\"  Description,\"\n                        f\"  LastUpdated\"\n                        f\" ) \"\n                        f\"{_ret.output}\"\n                        f\" values (\"\n                        f\"{_ret.sequence}\"\n                        f\"  :ListName,\"\n                        f\"  :ListType,\"\n                        f\"  :Description,\"\n                        f\"  :LastUpdated\"\n                        f\" )\"\nf\"{_ret.tail}\") # (2)!\ntext_statement = statement.columns(ID=sa.types.Integer,\n                                      )\n        text_statement = text_statement.bindparams(ListName=ListName,\n                                         ListType=ListType,\n                                         Description=Description,\n                                         LastUpdated=LastUpdated,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ListName: str\n                     , ListType: ListTypeEnum\n                     , Description: str\n                     , LastUpdated: datetime\n                     ) -&gt; Optional['DB_ToDoListInsertReturning']:\n        params = process_bind_params(session, [db_types.NonNullableString,\n                                        sa.types.SmallInteger,\n                                        db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        ], [ListName,\n                                        ListType.value if isinstance(ListType, enum.Enum) else ListType,\n                                        Description,\n                                        LastUpdated,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_ToDoListInsertReturning, session, [sa.types.Integer,\n                                        ], rec)\n\n        return None\n</code></pre> <ol> <li>Different database engine have different ways of returning records. Postgres requires a postfix or \"tail\"    which specifies which colunns to return. Here we are setting up the postgres returning section.</li> <li>Here we inject the Posrgres \"tail\" we set up above.</li> </ol> InsertInsert Returning <pre><code>public void insert() throws SQLException\n{\nString statement = \"/* PROC BooksAndAuthors.ToDoList.Insert */\"\n+ \"insert into BooksAndAuthors.ToDoList (\"\n+ \"  ListName,\"\n+ \"  ListType,\"\n+ \"  Description,\"\n+ \"  LastUpdated\"\n+ \" ) \"\n+ \" values (\"\n+ \"  ?,\"\n+ \"  ?,\"\n+ \"  ?,\"\n+ \"  ?\"\n+ \" )\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nlastUpdated = connector.getTimestamp();\nprep.setString(1, listName);\nprep.setShort(2, listType);\nprep.setString(3, description);\nprep.setTimestamp(4, lastUpdated);\nprep.executeUpdate();\nprep.close();\n}\n</code></pre> <pre><code>public boolean insert() throws SQLException\n{\nConnector.Returning _ret = connector.getReturning(\"ToDoList\",\"ID\"); // (1)!\nString statement = \"/* PROC BooksAndAuthors.ToDoList.Insert */\"\n+ \"insert into BooksAndAuthors.ToDoList (\"\n+ \"  ID,\"\n+ \"  ListName,\"\n+ \"  ListType,\"\n+ \"  Description,\"\n+ \"  LastUpdated\"\n+ \" ) \"\n+  {_ret.output} + \" values (\"\n+  {_ret.sequence} + \"  ?,\"\n+ \"  ?,\"\n+ \"  ?,\"\n+ \"  ?\"\n+ \" )\"\n+  {_ret.tail} // (2)!\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nlastUpdated = connector.getTimestamp();\nprep.setString(1, listName);\nprep.setShort(2, listType);\nprep.setString(3, description);\nprep.setTimestamp(4, lastUpdated);\nResultSet result = prep.executeQuery();\nif (!result.next())\n{\nresult.close();\nprep.close();\nreturn false;\n}\nid =  result.getInt(1);\nresult.close();\nprep.close();\nreturn true;\n}\n</code></pre> <ol> <li>Different database engine have different ways of returning records. Postgres requires a postfix or \"tail\"    which specifies which colunns to return. Here we are setting up the postgres returning section.</li> <li>Here we inject the Posrgres \"tail\" we set up above.</li> </ol>"},{"location":"Howto/inserting-rows/#bulkinsert","title":"BulkInsert","text":"<p>Insert new records in bulk.</p> <pre><code>BulkInsert [&lt;rowcount&gt;] \n</code></pre> <p>BulkInsert will insert records into a table in bulk. Adding the <code>&lt;rowcount&gt;</code> clause will cause JPortal2 to batch the inserts into batches of size . If <code>&lt;rouwcount&gt;</code> is omitted, JPortal2 will default to batches of size 1 000. --template-generator SQLAlchemy--builtin-generator JavaJCCode <p>Warning</p> <p>NOT CURRENTLY SUPPORTED IN SQLALCHEMY GENERATOR</p> <pre><code>  public void bulkInsert(List&lt;ToDoList&gt; records) throws SQLException\n{\nString statement = \"/* PROC BooksAndAuthors.ToDoList.BulkInsert */\"\n+ \"insert into BooksAndAuthors.ToDoList (\"\n+ \"  ListName,\"\n+ \"  ListType,\"\n+ \"  Description,\"\n+ \"  LastUpdated\"\n+ \" ) \"\n+ \" values (\"\n+ \"  ?,\"\n+ \"  ?,\"\n+ \"  ?,\"\n+ \"  ?\"\n+ \" )\"\n;\nfor (int batchSize=0; batchSize &lt;= Math.ceil(records.size()/1000); batchSize++ ) {\nPreparedStatement prep = connector.prepareStatement(statement);\nfor (int recCount=(batchSize*1000); recCount &lt; (batchSize+1)*1000 &amp;&amp; recCount &lt; records.size(); recCount++) {\nToDoList record = records.get(recCount);\nlastUpdated = connector.getTimestamp();\nprep.setString(1, record.listName);\nprep.setShort(2, record.listType);\nprep.setString(3, record.description);\nprep.setTimestamp(4, lastUpdated);\nprep.addBatch();\n}\nprep.executeBatch();\nprep.close();\n}\n}\n</code></pre>"},{"location":"Howto/retrieving-rows/","title":"Retrieving rows","text":""},{"location":"Howto/retrieving-rows/#built-in-procs","title":"Built-In Procs","text":"<p>JPortal ships with a number of built-in procs to allow easy querying of a database.</p> <p>Let assume the following table structure in our SI, with various procs defined to retrieve records:</p> <pre>\n<code>\nDATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA BooksAndAuthors\n\nTABLE Authors\n   ID               SEQUENCE\n   Bio              CHAR\n   BirthDate        DATE\n   LastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\n    ID\n\n\n//Simple CRUD queries are available out of the box with JPortal2\nPROC SelectOne\nPROC SelectAll\nPROC SelectOneBy Bio\nPROC SelectBy BirthDate Returning Bio\nPROC SelectBy BirthDate As FancySelectByBirthDate\nOUTPUT\n    ID          =\n    Bio         =\n    BirthDate   =\n</code>\n</pre> <p>Let's work through the above.  </p>"},{"location":"Howto/retrieving-rows/#selectone","title":"SelectOne","text":"<p>Selects a record by its primary key.</p> <pre><code>SelectOne  \n[ FOR &lt;UPDATE | READONLY&gt; ]\n</code></pre> <p>SelectOne will select all the fields of a table, by primary key. Adding the FOR UPDATE clause will cause JPortal2 to add the text <code>FOR UPDATE</code> to the query. Use this to lock a record for when you want to select it, change on or more fields, and then update it. Adding the FOR READONLY clause will cause JPortal2 to add the text \"FOR READONLY\" to the query. Use this to  put a READONLY lock on a record.</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode SelectOneSelectOne FOR UPDATESelectOne FOR READONLY <pre><code>@dataclass\nclass DB_AuthorsSelectOne:\n    #Outputs\n    Bio: str\n    BirthDate: datetime\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     , ID: int\n                     ) -&gt; TextAsFrom:\n\n        statement = sa.text(\n                        f\"/* PROC BooksAndAuthors.Authors.SelectOne */\"\n                        f\"select\"\n                        f\"  Bio\"\n                        f\", BirthDate\"\n                        f\", LastUpdated\"\n                        f\" from BooksAndAuthors.Authors\"\n                        f\" where ID = :ID\")\n\n        text_statement = statement.columns(Bio=db_types.NonNullableString,\n                                      BirthDate=sa.types.DateTime,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        text_statement = text_statement.bindparams(ID=ID,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ID: int\n                     ) -&gt; Optional['DB_AuthorsSelectOne']:\n        params = process_bind_params(session, [sa.types.Integer,\n                                        ], [ID,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_AuthorsSelectOne, session, [db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        sa.types.DateTime,\n                                        ], rec)\n\n        return None\n</code></pre> <pre><code>@dataclass\nclass DB_AuthorsSelectOneUpd:\n    #Outputs\n    Bio: str\n    BirthDate: datetime\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     , ID: int\n                     ) -&gt; TextAsFrom:\n\n        statement = sa.text(\n                        f\"/* PROC BooksAndAuthors.Authors.SelectOneUpd */\"\n                        f\"select\"\n                        f\"  Bio\"\n                        f\", BirthDate\"\n                        f\", LastUpdated\"\n                        f\" from BooksAndAuthors.Authors\"\n                        f\" where ID = :ID\"\n                        f\" for update\")\n\n        text_statement = statement.columns(Bio=db_types.NonNullableString,\n                                      BirthDate=sa.types.DateTime,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        text_statement = text_statement.bindparams(ID=ID,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ID: int\n                     ) -&gt; Optional['DB_AuthorsSelectOneUpd']:\n        params = process_bind_params(session, [sa.types.Integer,\n                                        ], [ID,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_AuthorsSelectOneUpd, session, [db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        sa.types.DateTime,\n                                        ], rec)\n\n        return None\n</code></pre> <pre><code>@dataclass\nclass DB_AuthorsSelectOneReadOnly:\n    #Outputs\n    Bio: str\n    BirthDate: datetime\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     , ID: int\n                     ) -&gt; TextAsFrom:\n\n        statement = sa.text(\n                        f\"/* PROC BooksAndAuthors.Authors.SelectOneUpd */\"\n                        f\"select\"\n                        f\"  Bio\"\n                        f\", BirthDate\"\n                        f\", LastUpdated\"\n                        f\" from BooksAndAuthors.Authors\"\n                        f\" where ID = :ID\"\n                        f\" for read only\")\n\n        text_statement = statement.columns(Bio=db_types.NonNullableString,\n                                      BirthDate=sa.types.DateTime,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        text_statement = text_statement.bindparams(ID=ID,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ID: int\n                     ) -&gt; Optional['DB_AuthorsSelectOneUpd']:\n        params = process_bind_params(session, [sa.types.Integer,\n                                        ], [ID,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_AuthorsSelectOneUpd, session, [db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        sa.types.DateTime,\n                                        ], rec)\n\n        return None\n</code></pre> SelectOneSelectOne FOR UPDATESelectOne FOR READONLY <pre><code>public boolean selectOne() throws SQLException\n{\nString statement =\n\"/* PROC ToDoList_App.Authors.SelectOne */\"\n+ \"select\"\n+ \"  Bio\"\n+ \", BirthDate\"\n+ \", LastUpdated\"\n+ \" from ToDoList_App.Authors\"\n+ \" where ID = ?\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.setInt(1, id);\nResultSet result = prep.executeQuery();\nif (!result.next())\n{\nresult.close();\nprep.close();\nreturn false;\n}\nbio =  result.getString(1);\nbirthDate =  result.getDate(2);\nlastUpdated =  result.getTimestamp(3);\nresult.close();\nprep.close();\nreturn true;\n}\n</code></pre> <pre><code>public boolean selectOneUpd() throws SQLException\n{\nString statement =\n\"/* PROC ToDoList_App.Authors.SelectOneUpd */\"\n+ \"select\"\n+ \"  Bio\"\n+ \", BirthDate\"\n+ \", LastUpdated\"\n+ \" from ToDoList_App.Authors\"\n+ \" where ID = ?\"\n+ \" for update\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.setInt(1, id);\nResultSet result = prep.executeQuery();\nif (!result.next())\n{\nresult.close();\nprep.close();\nreturn false;\n}\nbio =  result.getString(1);\nbirthDate =  result.getDate(2);\nlastUpdated =  result.getTimestamp(3);\nresult.close();\nprep.close();\nreturn true;\n}\n</code></pre> <pre><code>public boolean selectOneReadOnly() throws SQLException\n{\nString statement =\n\"/* PROC ToDoList_App.Authors.SelectOneReadOnly */\"\n+ \"select\"\n+ \"  Bio\"\n+ \", BirthDate\"\n+ \", LastUpdated\"\n+ \" from ToDoList_App.Authors\"\n+ \" where ID = ?\"\n+ \" for read only\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.setInt(1, id);\nResultSet result = prep.executeQuery();\nif (!result.next())\n{\nresult.close();\nprep.close();\nreturn false;\n}\nbio =  result.getString(1);\nbirthDate =  result.getDate(2);\nlastUpdated =  result.getTimestamp(3);\nresult.close();\nprep.close();\nreturn true;\n}\n</code></pre>"},{"location":"Howto/retrieving-rows/#selectall","title":"SelectAll","text":"<p>Selects all the records in a table.</p> <pre><code>SelectAll   [ [IN] ORDER &lt;OrderColumnName&gt;* [DESC]]   [ FOR &lt;UPDATE | READONLY&gt; ]\n</code></pre> <p>SelectAll will select all the records of a table.</p> <p>Adding the IN ORDER clause will add <code>ORDER BY &lt;specified columns&gt;</code> to the query. Specify </p> <p>Adding the FOR UPDATE clause will cause JPortal2 to add the text <code>FOR UPDATE</code> to the query. Use this to lock a record for when you want to select it, change on or more fields, and then update it. Adding the FOR READONLY clause will cause JPortal2 to add the text \"FOR READONLY\" to the query. Use this to put a READONLY lock on a record. See SelectOne for an example of <code>FOR &lt;UPDATE | READONLY&gt;</code>.</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode SelectAllSelectAll IN ORDER <pre><code>@dataclass\nclass DB_AuthorsSelectAll:\n    #Outputs\n    ID: int\n    Bio: str\n    BirthDate: datetime\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     ) -&gt; TextAsFrom:\n\n        statement = sa.text(\n                        f\"/* PROC BooksAndAuthors.Authors.SelectAll */\"\n                        f\"select\"\n                        f\"  ID\"\n                        f\", Bio\"\n                        f\", BirthDate\"\n                        f\", LastUpdated\"\n                        f\" from BooksAndAuthors.Authors\")\n\n        text_statement = statement.columns(ID=sa.types.Integer,\n                                      Bio=db_types.NonNullableString,\n                                      BirthDate=sa.types.DateTime,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session) -&gt; List['DB_AuthorsSelectAll']:\n        res = session.execute(cls.get_statement())\n        recs = res.fetchall()\n        return process_result_recs(DB_AuthorsSelectAll, session, [sa.types.Integer,\n                                        db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        sa.types.DateTime,\n                                        ], recs)\n</code></pre> <pre><code>@dataclass\nclass DB_AuthorsSelectAllSorted:\n    #Outputs\n    ID: int\n    Bio: str\n    BirthDate: datetime\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     ) -&gt; TextAsFrom:\n\n        statement = sa.text(\n                        f\"/* PROC BooksAndAuthors.Authors.SelectAllSorted */\"\n                        f\"select\"\n                        f\"  ID\"\n                        f\", Bio\"\n                        f\", BirthDate\"\n                        f\", LastUpdated\"\n                        f\" from BooksAndAuthors.Authors\"\n                        f\" order by Bio\"\n                        f\", ID desc\")\n\n        text_statement = statement.columns(ID=sa.types.Integer,\n                                      Bio=db_types.NonNullableString,\n                                      BirthDate=sa.types.DateTime,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session) -&gt; List['DB_AuthorsSelectAllSorted']:\n        res = session.execute(cls.get_statement())\n        recs = res.fetchall()\n        return process_result_recs(DB_AuthorsSelectAllSorted, session, [sa.types.Integer,\n                                        db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        sa.types.DateTime,\n                                        ], recs)\n</code></pre> SelectAllSelectAll IN ORDER <pre><code>/**\n* Returns any number of records.\n* @return result set of records found\n* @exception SQLException is passed through\n*/\npublic Query selectAll() throws SQLException\n{\nString statement =\n\"/* PROC ToDoList_App.Authors.SelectAllSorted */\"\n+ \"select\"\n+ \"  ID\"\n+ \", Bio\"\n+ \", BirthDate\"\n+ \", LastUpdated\"\n+ \" from ToDoList_App.Authors\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nResultSet result = prep.executeQuery();\nQuery query = new Query(prep, result);\nreturn query;\n} </code></pre> <pre><code>/**\n* Returns any number of records.\n* @return result set of records found\n* @exception SQLException is passed through\n*/\npublic Query selectAllSorted() throws SQLException\n{\nString statement =\n\"/* PROC ToDoList_App.Authors.SelectAllSorted */\"\n+ \"select\"\n+ \"  ID\"\n+ \", Bio\"\n+ \", BirthDate\"\n+ \", LastUpdated\"\n+ \" from ToDoList_App.Authors\"\n+ \" order by Bio\"\n+ \", ID desc\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nResultSet result = prep.executeQuery();\nQuery query = new Query(prep, result);\nreturn query;\n} </code></pre>"},{"location":"Howto/retrieving-rows/#selectoneby","title":"SelectOneBy","text":"<p>Selects a record by user specified columns.</p> <pre><code>SelectOneBy &lt;SelectColumns&gt;+\n[ FOR &lt;UPDATE | READONLY&gt; ]\n</code></pre> <p>SelectOneBy will select all the fields of a table, by the keys specified by <code>SelectColumns</code>. Adding the FOR UPDATE clause will cause JPortal2 to add the text <code>FOR UPDATE</code> to the query. Use this to lock a record for when you want to select it, change on or more fields, and then update it. Adding the FOR READONLY clause will cause JPortal2 to add the text \"FOR READONLY\" to the query. Use this to  put a READONLY lock on a record. See SelectOne for an example of <code>FOR &lt;UPDATE | READONLY&gt;</code>.  </p> --template-generator SQLAlchemy--builtin-generator JavaJCCode SelectOneBy <pre><code>@dataclass\nclass DB_AuthorsSelectOneByBio:\n    #Outputs\n    ID: int\n    Bio: str\n    BirthDate: datetime\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     , Bio: str\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \" OUTPUT (ID,Bio,BirthDate,LastUpdated)\"\n            tail = \" RETURNING ID Bio BirthDate LastUpdated\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC BooksAndAuthors.Authors.SelectOneByBio */\"\n                        f\"select\"\n                        f\"  ID\"\n                        f\", Bio\"\n                        f\", BirthDate\"\n                        f\", LastUpdated\"\n                        f\" from BooksAndAuthors.Authors\"\n                        f\" for update\"\n                        f\" where Bio = :Bio\")\n\n        text_statement = statement.columns(ID=sa.types.Integer,\n                                      Bio=db_types.NonNullableString,\n                                      BirthDate=sa.types.DateTime,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        text_statement = text_statement.bindparams(Bio=Bio,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, Bio: str\n                     ) -&gt; Optional['DB_AuthorsSelectOneByBio']:\n        params = process_bind_params(session, [db_types.NonNullableString,\n                                        ], [Bio,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_AuthorsSelectOneByBio, session, [sa.types.Integer,\n                                        db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        sa.types.DateTime,\n                                        ], rec)\n\n        return None\n</code></pre> SelectOneBy <pre><code>/**\n* Returns at most one record.\n* @return true if a record is found\n* @exception SQLException is passed through\n*/\npublic boolean selectOneByBio() throws SQLException\n{ String statement = \"/* PROC ToDoList_App.Authors.SelectOneByBio */\"\n+ \"select\"\n+ \"  ID\"\n+ \", Bio\"\n+ \", BirthDate\"\n+ \", LastUpdated\"\n+ \" from ToDoList_App.Authors\"\n+ \" for update\"\n+ \" where Bio = ?\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.setString(1, bio);\nResultSet result = prep.executeQuery();\nif (!result.next())\n{\nresult.close();\nprep.close();\nreturn false;\n}\nid =  result.getInt(1);\nbio =  result.getString(2);\nbirthDate =  result.getDate(3);\nlastUpdated =  result.getTimestamp(4);\nresult.close();\nprep.close();\nreturn true;\n}\n</code></pre>"},{"location":"Howto/retrieving-rows/#selectby","title":"SelectBy","text":"<p>Selects record by user specified keys,columns returning columns specified by user</p> <pre><code>SelectBy &lt;SelectColumns&gt;+\n[ [IN] ORDER &lt;OrderColumnName&gt;* [DESC]]   \n[ FOR UPDATE | READONLY ]\n[AS &lt;alias&gt;]\n[RETURNING &lt;columns to return&gt;]\n</code></pre> <p>SelectBy will select the fields of a table that are specified by the <code>RETURNING</code> clause, by the keys specified  by <code>SelectColumns</code>. Adding the FOR UPDATE clause will cause JPortal2 to add the text <code>FOR UPDATE</code> to the query. Use this to lock a record for when you want to select it, change on or more fields, and then update it. Adding the FOR READONLY clause will cause JPortal2 to add the text \"FOR READONLY\" to the query. Use this to put a READONLY lock on a record. See SelectOne for an example of <code>FOR &lt;UPDATE | READONLY&gt;</code>. the <code>AS</code> clause specifies a custom name for the proc. If <code>AS</code> is omitted, the name will default to <code>SelectBy&lt;SelectColumns&gt;</code>. The <code>RETURNING</code> clause specifies the fields that must be returned, If it is omitted, all the fields in the table will be returned.  </p> --template-generator SQLAlchemy--builtin-generator JavaJCCode SelectBy <pre><code>        @dataclass\n        class DB_AuthorsSelectByBirthDate:\n        #Outputs\n        Bio: str\n\n        @classmethod\n        def get_statement(cls\n                         , BirthDate: datetime\n                         ) -&gt; TextAsFrom:\n            class _ret:\n                sequence = \"default,\" #postgres uses default for sequences\n                output = \" OUTPUT (Bio)\"\n                tail = \" RETURNING Bio\"\n                #session.bind.dialect.name\n\n            statement = sa.text(\n                            f\"/* PROC BooksAndAuthors.Authors.SelectByBirthDate */\"\n                            f\"select\"\n                            f\"  Bio\"\n                            f\" from BooksAndAuthors.Authors\"\n                            f\" where BirthDate = :BirthDate\")\n\n            text_statement = statement.columns(Bio=db_types.NonNullableString,\n                                          )\n            text_statement = text_statement.bindparams(BirthDate=BirthDate,\n                                             )\n            return text_statement\n\n        @classmethod\n        def execute(cls, session: Session, BirthDate: datetime\n                         ) -&gt; List['DB_AuthorsSelectByBirthDate']:\n            params = process_bind_params(session, [sa.types.DateTime,\n                                            ], [BirthDate,\n                                            ])\n            res = session.execute(cls.get_statement(*params))\n            recs = res.fetchall()\n            return process_result_recs(DB_AuthorsSelectByBirthDate, session, [db_types.NonNullableString,\n                                            ], recs)\n</code></pre> SelectOneBy <pre><code>    /**\n    * Returns any number of records.\n    * @return result set of records found\n    * @exception SQLException is passed through\n    */\npublic Query selectByBirthDate() throws SQLException\n{\nString statement =\n\"/* PROC ToDoList_App.Authors.SelectByBirthDate */\"\n+ \"select\"\n+ \"  Bio\"\n+ \" from ToDoList_App.Authors\"\n+ \" where BirthDate = ?\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nprep.setDate(1, birthDate);\nResultSet result = prep.executeQuery();\nQuery query = new Query(prep, result);\nreturn query;\n}\n</code></pre>"},{"location":"Howto/retrieving-rows/#custom-procs","title":"Custom Procs","text":"<p>If the built-in select functions don't give you the power and flexibility you need, you can write your own  select function using a Custom Proc, which is covered in the next section.</p>"},{"location":"Howto/updating-rows/","title":"Updating rows","text":""},{"location":"Howto/updating-rows/#built-in-procs","title":"Built-In Procs","text":"<p>JPortal ships with a number of built-in procs to allow easy updating of data into a database.</p> <p>Let assume the following table structure in our SI, with various procs defined to update records:</p> <pre>\n<code>\nDATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDoList\n   ID               SEQUENCE\n   ListName         CHAR(255)\n   ListType         SHORT (Private=1, Public=2)\n   Description      CHAR(255)\n   LastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\n    ID\n\n//Simple CRUD queries are available out of the box with JPortal2\nPROC Update\nPROC UpdateBy ListName\nPROC UpdateBy ListName SET ListType Description AS UpdateListTypeDescriptionByListName\n\n&lt;</code>\n</pre> <p>Let's work through the above.</p>"},{"location":"Howto/updating-rows/#update","title":"Update","text":"<p>Updates an existing record by primary key.</p> <pre><code>Update\n</code></pre> <p>Update will update an existing record in a table, by primary key. If no primary key is specified on the table, JPortal2 will issue a warning at compile time.</p> <p>Note</p> <p>Note that Update will update ALL the columns of the record. If you want to only update certain columns,  consider using UpdateBy or a custom proc to achieve what you want.</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode <pre><code>@dataclass\nclass DB_ToDoListUpdate:\n# Enum for ListType field\nclass ListTypeEnum(enum.Enum):\n    Private = 1\n    Public = 2\n\n    @classmethod\n    def process_result_value_cls(cls, value, dialect):\n        return DB_ToDoListUpdate.ListTypeEnum(value)\n\n\n\n\n    @classmethod\n    def get_statement(cls\n                     , ListName: str\n                     , ListType: ListTypeEnum\n                     , Description: str\n                     , LastUpdated: datetime\n                     , ID: int\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \"\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"update ToDoList_App.ToDoList\"\n                        f\" set\"\n                        f\"  ListName = :ListName\"\n                        f\", ListType = :ListType\"\n                        f\", Description = :Description\"\n                        f\", LastUpdated = :LastUpdated\"\n                        f\" where ID = :ID\")\n\n        text_statement = statement.columns()\n        text_statement = text_statement.bindparams(ListName=ListName,\n                                         ListType=ListType,\n                                         Description=Description,\n                                         LastUpdated=LastUpdated,\n                                         ID=ID,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ListName: str\n                     , ListType: ListTypeEnum\n                     , Description: str\n                     , LastUpdated: datetime\n                     , ID: int\n                     ) -&gt; None:\n        params = process_bind_params(session, [db_types.NonNullableString,\n                                        sa.types.SmallInteger,\n                                        db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        sa.types.Integer,\n                                        ], [ListName,\n                                        ListType.value if isinstance(ListType, enum.Enum) else ListType,\n                                        Description,\n                                        LastUpdated,\n                                        ID,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        res.close()\n</code></pre> <pre><code>  public void update() throws SQLException\n{\nString statement = \"update BooksAndAuthors.ToDoList\"\n+ \" set\"\n+ \"  ListName = ?\"\n+ \", ListType = ?\"\n+ \", Description = ?\"\n+ \", LastUpdated = ?\"\n+ \" where ID = ?\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nlastUpdated = connector.getTimestamp();\nprep.setString(1, listName);\nprep.setShort(2, listType);\nprep.setString(3, description);\nprep.setTimestamp(4, lastUpdated);\nprep.setInt(5, id);\nprep.executeUpdate();\nprep.close();\n}\n</code></pre>"},{"location":"Howto/updating-rows/#updateby","title":"UpdateBy","text":"<p>Updates an existing record by user specified keys.</p> <pre><code>UpdateBy &lt;UpdateKeys&gt;+ \n[SET &lt;ColumnToUpdate&gt;+]\n[AS &lt;alias&gt;] \n</code></pre> <p>UpdateBy will update the columns of a record that are specified by the <code>SET</code> clause, by the keys specified by <code>UpdateKeys</code>. The <code>AS</code> clause specifies a custom name for the proc. If <code>AS</code> is omitted, the name will default to <code>UpdateBy&lt;SelectKeys&gt;</code>.  </p> --template-generator SQLAlchemy--builtin-generator JavaJCCode <pre><code>@dataclass\nclass DB_ToDoListUpdateBy:\n    # Enum for ListType field\n    class ListTypeEnum(enum.Enum):\n        Private = 1\n        Public = 2\n\n    @classmethod\n    def process_result_value_cls(cls, value, dialect):\n        return DB_ToDoListUpdateBy.ListTypeEnum(value)\n\n\n\n\n    @classmethod\n    def get_statement(cls\n                     , ListType: ListTypeEnum\n                     , Description: str\n                     , LastUpdated: datetime\n                     , ListName: str\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \"\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDoList.UpdateBy */\"\n                        f\"update ToDoList_App.ToDoList\"\n                        f\" set\"\n                        f\"  ListType = :ListType\"\n                        f\", Description = :Description\"\n                        f\", LastUpdated = :LastUpdated\"\n                        f\" where ListName = :ListName\")\n\n        text_statement = statement.columns()\n        text_statement = text_statement.bindparams(ListType=ListType,\n                                         Description=Description,\n                                         LastUpdated=LastUpdated,\n                                         ListName=ListName,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ListType: ListTypeEnum\n                     , Description: str\n                     , LastUpdated: datetime\n                     , ListName: str\n                     ) -&gt; None:\n        params = process_bind_params(session, [sa.types.SmallInteger,\n                                        db_types.NonNullableString,\n                                        sa.types.DateTime,\n                                        db_types.NonNullableString,\n                                        ], [ListType.value if isinstance(ListType, enum.Enum) else ListType,\n                                        Description,\n                                        LastUpdated,\n                                        ListName,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        res.close() \n</code></pre> <pre><code>  public void updateBy() throws SQLException\n{\nString statement = \"/* PROC BooksAndAuthors.ToDoList.UpdateBy */\"\n+ \"update BooksAndAuthors.ToDoList\"\n+ \" set\"\n+ \"  ListType = ?\"\n+ \", Description = ?\"\n+ \", LastUpdated = ?\"\n+ \" where ListName = ?\"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nlastUpdated = connector.getTimestamp();\nprep.setShort(1, listType);\nprep.setString(2, description);\nprep.setTimestamp(3, lastUpdated);\nprep.setString(4, listName);\nprep.executeUpdate();\nprep.close();\n}\n</code></pre>"},{"location":"Howto/updating-rows/#bulkupdate","title":"BulkUpdate","text":"<p>Updates existing records in bulk.</p> <pre><code>BulkUpdate [&lt;rowcount&gt;] \n</code></pre> <p>BulkUpdate will update existing records in a table in bulk. Adding the <code>&lt;rowcount&gt;</code> clause will cause JPortal2 to batch the updates into batches of size . If <code>&lt;rouwcount&gt;</code> is omitted, JPortal2 will default to batches of size 1 000. --template-generator SQLAlchemy--builtin-generator JavaJCCode <p>Warning</p> <p>NOT CURRENTLY SUPPORTED IN SQLALCHEMY GENERATOR</p> <pre><code>public void bulkUpdate(List&lt;ToDoList&gt; records) throws SQLException\n{\nString statement = \"update BooksAndAuthors.ToDoList\"\n+ \" set\"\n+ \"  ListName = ?\"\n+ \", ListType = ?\"\n+ \", Description = ?\"\n+ \", LastUpdated = ?\"\n+ \" where ID = ?\"\n;\nfor (int batchSize=0; batchSize &lt;= Math.ceil(records.size()/1000); batchSize++ ) {\nPreparedStatement prep = connector.prepareStatement(statement);\nfor (int recCount=(batchSize*1000); recCount &lt; (batchSize+1)*1000 &amp;&amp; recCount &lt; records.size(); recCount++) {\nToDoList record = records.get(recCount);\nlastUpdated = connector.getTimestamp();\nprep.setString(1, record.listName);\nprep.setShort(2, record.listType);\nprep.setString(3, record.description);\nprep.setTimestamp(4, lastUpdated);\nprep.setInt(5, record.id);\nprep.addBatch();\n}\nprep.executeBatch();\nprep.close();\n}\n}\n</code></pre>"},{"location":"Howto/using-enums/","title":"Using enums","text":"<p>Enums are a very useful programming construct. JPortal has some powerful mechanisms for working with enums.</p> <pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDoList\n   ID               SEQUENCE\n   ListName         CHAR(255)\n   ListType         SHORT (Private=1, Public=2)\n   Description      CHAR(255)\n   LastUpdated      TIMESTAMP\n\nPROC EnumExampleReturnAllPublicLists\nOUTPUT\n    ID          =\n    ListName    =\n    ListType    =\nSQLCODE\n    SELECT \n            ID,\n            ListName,\n            ListType\n    FROM    \n            ToDoList\n    WHERE   \n            ListType = %ListType.Public%\nENDCODE\n</code></pre> <p>In the above table definition, line 9 defines <code>ListType</code> as an enum with 2 values:  </p> Key Value 1 Private 2 Public"},{"location":"Howto/using-enums/#using-enums-in-your-code","title":"Using enums in your code","text":"<p>In the generated code this will allow you to use enums instead of magic numbers in your code. For example:</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode <pre><code>@dataclass\nclass DB_ToDoListBulkInsert:\n    # Enum for ListType field\n    class ListTypeEnum(enum.Enum):\n        Private = 1\n        Public = 2\n</code></pre> <pre><code>public class ToDoListStruct implements Serializable\n{\npublic static final long serialVersionUID = 1L;\npublic enum ListType\n{\nPRIVATE(1, \"Private\"),\nPUBLIC(2, \"Public\");\npublic int key;\npublic String value;\nListType(int key, String value)\n{\nthis.key = key;\nthis.value = value;\n}\npublic static ListType get(int key)\n{\nfor (ListType op : values())\nif (op.key == key) return op;\nreturn null;\n}\npublic String toString()\n{\nreturn value;\n}\n}\nprotected Integer id;\npublic Integer getID(){ return id; } public void setID(Integer  id){ this.id = id; }\n\nprotected String listName;\npublic String getListName(){ return listName; } public void setListName(String  listName){ this.listName = listName; }\n\nprotected Short listType;\npublic Short getListType(){ return listType; } public void setListType(Short  listType){ this.listType = listType; }\n\nprotected String description;\npublic String getDescription(){ return description; } public void setDescription(String  description){ this.description = description; }\n\nprotected Timestamp lastUpdated;\npublic Timestamp getLastUpdated(){ return lastUpdated; } public void setLastUpdated(Timestamp  lastUpdated){ this.lastUpdated = lastUpdated; }\n\npublic ToDoListStruct()\n{\nid = null;\nlistName = null;\nlistType = null;\ndescription = null;\nlastUpdated = new Timestamp(0);\n}\npublic String toString()\n{\nString CRLF = System.lineSeparator();\nreturn \"  id          : \" + id + CRLF\n+ \"  listName    : \" + listName + CRLF\n+ \"  listType    : \" + listType + CRLF\n+ \"  description : \" + description + CRLF\n+ \"  lastUpdated : \" + lastUpdated + CRLF\n;\n}\n}\n</code></pre>"},{"location":"Howto/using-enums/#using-enums-in-sql","title":"Using enums in SQL","text":"<p>To use the above enums in your SQL code, you can use the syntax <code>%&lt;ColumnName&gt;.&lt;EnumValue&gt;</code>.</p> <p>So for example if you wanted to select all records where ListType is Public (i.e. 2), you could write <pre><code>    WHERE   \n            ListType = %ListType.Public%\n</code></pre> which would generate</p> --template-generator SQLAlchemy--builtin-generator JavaJCCode <pre><code>\n</code></pre> <pre><code>public Query enumExampleReturnAllPublicLists() throws SQLException\n{\nString statement =\n\"/* PROC BooksAndAuthors.ToDoList.EnumExampleReturnAllPublicLists */\"\n+ \"SELECT \"\n+ \"ID, \"\n+ \"ListName, \"\n+ \"ListType \"\n+ \"FROM \"\n+ \"ToDoList \"\n+ \"WHERE \"\n+ \"ListType = 2 \"\n;\nPreparedStatement prep = connector.prepareStatement(statement);\nResultSet result = prep.executeQuery();\nQuery query = new Query(prep, result);\nreturn query;\n}\n</code></pre>"},{"location":"Howto/using-grants/","title":"Using Grants","text":"<p>JPortal2 allows you to specify database permission grants.</p> <pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA BooksAndAuthors\n\nTABLE Books\n   ID               SEQUENCE\n   AuthorID         INT\n   Title            CHAR(255)\n   PublishDate      DATE\n   LastUpdated      TIMESTAMP\n\nGRANT all TO db_user\n</code></pre>"},{"location":"Howto/using-grants/#grant","title":"GRANT","text":"<p>Grants permissions to a db user.</p> <pre><code>GRANT  \nALL | DELETE | INSERT | SELECT | UPDATE | EXECUTE\nTO \n&lt;user&gt;+ \n</code></pre> <p><code>Grant</code> will grant permissions to database user. <code>ALL | DELETE | INSERT | SELECT | UPDATE | EXECUTE</code> specifies the permissions to grant. <code>user</code> is/are the database user(s) to grant permissions to.</p>"},{"location":"Howto/using-keys-indexes-and-foreign-keys/","title":"Using keys, indexes and foreign keys","text":"<p>To create indexes in JPortal2 is easy:</p> <pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA BooksAndAuthors\n\nTABLE Books\n   ID               SEQUENCE\n   AuthorID         INT\n   Title            CHAR(255)\n   PublishDate      DATE\n   LastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\n    ID\n\nLINK Authors DELETE CASCADE AuthorID \n</code></pre>"},{"location":"Howto/using-keys-indexes-and-foreign-keys/#primary-keys-and-indexes","title":"Primary Keys and Indexes","text":""},{"location":"Howto/using-keys-indexes-and-foreign-keys/#key","title":"KEY","text":"<p>Creates a primary key or index on a table.</p> <pre><code>KEY &lt;key_name&gt; \n[OPTIONS ( &lt;options_name&gt;+ ]\n[PRIMARY | UNIQUE ] \n&lt;key_columns&gt;+\n</code></pre> <p><code>Key</code> will create a primary key or index on a table. <code>&lt;key_name&gt;</code> is the name of the index to be created. <code>OPTIONS</code> specifies the options for the index. These options get passed through to the underlying generator, so the available options depend on the generator itself, but one example is <code>OPTIONS tablespace ABC</code> will place the index in the ABC tablespace when using the Db2DDL generator. <code>PRIMARY</code> indicates that you want to create a primary key, as opposed to an index. <code>UNIQUE</code> indicates that the index must be a unique index. <code>&lt;key_columns</code> contains the names of the columns to be included in the index</p>"},{"location":"Howto/using-keys-indexes-and-foreign-keys/#foreign-keys","title":"Foreign Keys","text":""},{"location":"Howto/using-keys-indexes-and-foreign-keys/#link","title":"LINK","text":"<p>Create a foreign key to a parent table.</p> <pre><code>LINK &lt;parent_table&gt; \n[DELETE [CASCADE]]\n[UPDATE [CASCADE]]\n[OPTIONS ( &lt;options_name&gt;+ ] \n&lt;key_columns&gt;+\n</code></pre> <p><code>Link</code> will create a a foreign key to a parent table. <code>&lt;parent_table&gt;</code> is the name of the parent table to create the foreign key to. <code>DELETE CASCADE</code> and <code>UPDATE CASCADE</code> will specify cascading deletes or updates to the parent table. <code>OPTIONS</code> specifies the options for the index. These options get passed through to the underlying generator, so the available options depend on the generator itself. <code>&lt;key_columns</code> contains the names of the columns in this SI to be used for the foreign key link. The foreign key will always be created to the Primary Key of the parent table.  </p>"},{"location":"Howto/using-literals/","title":"Using literals","text":""},{"location":"Howto/using-literals/#using-literals","title":"Using Literals","text":"<p>Occasionally you will want to use a word that is a reserved word, as the name of a table or a column. For example, consider the following SI file:</p> <p>todolist.si <pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDoList\nID               SEQUENCE\nListName         CHAR(255)\nListType         SHORT (Private=1, Public=2)\nL'Desc'          CHAR   //DESC is a reserved keyword!\nLastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\nID\n\n//Simple CRUD queries are available out of the box with JPortal2\nPROC Insert Returning\nPROC Update\nPROC SelectOne\nPROC DeleteOne\n</code></pre></p> <p>Notice that the Description column is named 'Desc', which is a reserved word (both in JPortal, as well as in SQL).  This will cause a JPortal compilation issue. To work around this, we turn the column name into a literal by  writing it as <code>L'Desc'</code>. This will allow the SI file to compile.</p>"},{"location":"Overview/installing-jportal2/","title":"Installing JPortal2","text":""},{"location":"Overview/installing-jportal2/#overview","title":"Overview","text":"<p>JPortal2 is distributed as a jar hosted on Maven Central as well as a command-line docker tool, for easy cross-platform usage.</p> <p>We recommend using the docker image for most projects.</p>"},{"location":"Overview/installing-jportal2/#docker","title":"Docker","text":""},{"location":"Overview/installing-jportal2/#installing-docker","title":"Installing docker","text":"<p>Install docker using the instructions here</p>"},{"location":"Overview/installing-jportal2/#installing-jportal2-docker-image","title":"Installing JPortal2 docker image","text":"<p>First pull the docker image for the version of JPortal you want to use. You can browse to https://github.com/si-gen/jportal2 to look at the available versions.</p> <pre><code>docker pull ghcr.io/si-gen/jportal2:1.8.14\n</code></pre> <p>Next run JPortal using <code>docker run</code> <pre><code>echo Running JPortal2 from ${PWD}...\n\ndocker run --rm -v ${PWD}:/local ghcr.io/si-gen/jportal2:1.8.14 \\\n--inputdir=/local/src/sql/si_files \\\n--template-generator \\\nSQLAlchemy:/local/src/python/bbdcontent/sqlalchemy \\\n--builtin-generator \\\nPostgresDDL:/local/database/generated_sql \\\n</code></pre></p>"},{"location":"Overview/installing-jportal2/#java","title":"Java","text":"<p>The Java JAR is hosted at https://ossindex.sonatype.org/component/pkg:maven/za.co.bbd/jportal2</p> <p>To use JPortal2 in your Maven based Java project, simply add the following to your POM: properties: <pre><code>&lt;properties&gt;    \n    &lt;jportal2.version&gt;1.3.0&lt;/jportal2.version&gt;\n    &lt;jportal2maven.version&gt;1.2.0&lt;/jportal2maven.version&gt;\n&lt;/properties&gt;\n</code></pre> dependencies: <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;za.co.bbd&lt;/groupId&gt;\n            &lt;artifactId&gt;jportal2&lt;/artifactId&gt;\n            &lt;version&gt;1.3.0&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre> and plugins: <pre><code>            &lt;plugin&gt;\n            &lt;groupId&gt;za.co.bbd&lt;/groupId&gt;\n            &lt;artifactId&gt;jportal2-maven-plugin&lt;/artifactId&gt;\n            &lt;version&gt;${jportal2maven.version}&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;sourcePath&gt;${basedir}/src/main/sql/&lt;/sourcePath&gt;\n                &lt;generators&gt;\n                    &lt;generator&gt;JavaJCCode:${basedir}/target/generated-sources/java/com/example/db&lt;/generator&gt;\n                    &lt;generator&gt;PostgresDDL:${basedir}/target/generated-sources/scripts/sql&lt;/generator&gt;\n                &lt;/generators&gt;\n                &lt;compilerFlags&gt;\n                    &lt;compilerFlag&gt;utilizeEnums&lt;/compilerFlag&gt;\n                &lt;/compilerFlags&gt;\n&lt;!--                    &lt;additionalArguments&gt;&amp;#45;&amp;#45;template-generator JdbiSqlObjects:${basedir}/target/generated-sources/java/&lt;/additionalArguments&gt;--&gt;\n            &lt;/configuration&gt;\n            &lt;dependencies&gt;\n                &lt;dependency&gt;\n                    &lt;groupId&gt;za.co.bbd&lt;/groupId&gt;\n                    &lt;artifactId&gt;jportal2&lt;/artifactId&gt;\n                    &lt;version&gt;${jportal2.version}&lt;/version&gt;\n                &lt;/dependency&gt;\n            &lt;/dependencies&gt;\n            &lt;executions&gt;\n               &lt;execution&gt;\n                 &lt;phase&gt;generate-sources&lt;/phase&gt;\n                     &lt;goals&gt;\n                        &lt;goal&gt;jportal&lt;/goal&gt;\n                    &lt;/goals&gt;\n            &lt;/execution&gt;\n            &lt;/executions&gt;\n        &lt;/plugin&gt;\n</code></pre></p> <p>JPortal2 is the actual Data Access Layer (DAL) generator. jportal2-maven-plugin is a plugin for maven that will run the generator at build time.</p>"},{"location":"Overview/installing-vscode-jportal2-extension/","title":"Installing the JPortal2 VSCode extension","text":""},{"location":"Overview/installing-vscode-jportal2-extension/#overview","title":"Overview","text":"<p>The JPortal2 VS Code extension is available on from the VSCode extensions tab.</p> <p>To install the JPortal extension, open VSCode, then choose the the Extensions tab on the left (Or press Ctrl-P and type \"install extensions\"). Type \"JPortal\" into the search field, choose the JPortal extension, and install it. See the video below:</p> <p></p> <p>It is on the todo list to have the VSCode plugin do a compile task, but for now, you can set up VSCode to compile your si, using a tasks.json file inside the .vscode directory in your project. Once set up, you can press Ctrl-Shift-B to run, or set it up with other keys.</p> <p>Instructions on how to set up tasks in VSCode are here</p> <p>Below is an example tasks.json file that will work for this demo:</p> <pre><code>{\n// See https://go.microsoft.com/fwlink/?LinkId=733558\n// for the documentation about the tasks.json format\n\"version\": \"2.0.0\",\n\"tasks\": [\n{\n\"label\": \"JPortal2\",\n\"type\": \"shell\",\n\"command\": \"./generate_jportal.sh\",\n\"windows\": {\n\"command\": \"wsl .\\\\generate_jportal.sh\"\n},\n\"options\": {\n\"cwd\": \"${workspaceFolder} \"\n},\n\"problemMatcher\": [],\n\"group\": {\n\"kind\": \"build\",\n\"isDefault\": true\n}\n}\n]\n}\n</code></pre>"},{"location":"Reference/Freemarker%20template/","title":"Freemarker template","text":""},{"location":"Reference/Freemarker%20template/#freemarker","title":"Freemarker","text":"<p>To use a Freemarker Template. Create a folder anywhere: \\$HOME/templates/Example Inside that folder create the freemarker template file: ExampleDB.py.ftl</p> <p>JPortal2 supports freemarker file name substitution. For example ExampleDB${table.name}.py.ftl will generate a ExampleDB{tablename}.py file for all the SI files you gen for.</p> <p>Inside your template file: <pre><code>&lt;#list database.tables as table&gt;\ntable name: ${table.name}:\n    table Fields:\n    &lt;#list table.fields as field&gt;${field.name}\n    &lt;/#list&gt;\n&lt;/#list&gt;\n</code></pre></p> <p>JPortal2 takes 2 arguments to run freemarker. The template location where all the templates folders are, and what templates you want to run.</p> <p>Run jportal with the argument: <pre><code>--template-location $HOME/templates/\n--template-generator ExampleDB:$HOME/output\n</code></pre></p> <p>When JPortal2 is done. You will have the generated files in the output directory and it will look like this: <pre><code>table name: ExampleTable\n    table fields:\n    id\n    name\n    surname\n</code></pre></p>"},{"location":"Reference/Freemarker%20template/#freemarker-variables","title":"Freemarker Variables","text":"<p>There are a few variables available to you in the freemarker template language for generation: - Database - Table - Proc</p> <p>The above variables match the hierarchy that is built into the SI structure. A database is a collection of SI files, and each SI file represents a table. Furthermore, each SI table has a collection of procs attached to it.</p> <p>The above variables are also available in the name component of the free-marker template file. That way one can create a generated file down to the level of each individual proc.</p>"},{"location":"Reference/Freemarker%20template/#workflow","title":"Workflow","text":"<p>A detailed description of the workflow process is mentioned in the Contribution.md Feel free to add any suggestions or any help in the</p>"},{"location":"Reference/Freemarker%20template/#documentation","title":"Documentation","text":"<p>For comprehensive documentation. Refer to the docs</p>"},{"location":"Reference/cli/","title":"Command-Line Interface","text":"Parameter Short form Description --debug -D Enable Debug logging --projectCompile -pc Enable project-level compilation --properties-file -pf A properties file with JPortal properties i.e. --propertiesfile=postgres.properties --log -l Logfile name i.e. --log=jportal2.log --inputdir -d Input Directory InputFiles List of input files --builtin-generator -o Built-In (Java-based) generatorName to run. Format is : i.e. --builtin-generator=CSNetCode:./cs --download-template-location -dtl Location in which to place downloaded Freemarker templates. Default is /jportal2_downloaded_templates --download-template -dt Download the specified template from the given location.Zip files as well as git repos are supported. Format is &lt;freemarker_generator_name&gt;:&lt;url&gt; [ | downloadSpecifier ]  i.e. <code>--download-template=MyCustomGenerator:https://github/SI-Gen/SQLAlchemy.zip</code> or<code>--download-template=MyCustomGenerator:https://github.com/SI-Gen/jportal2-generator-vanguard-sqlalchemy.git |1.3</code> NOTE THE REQUIRED TAG AT THE END OF THE GIT URL!!! For GIT, you MUST specify either a tag (recommended), or a branch.For ZIP, you can optionally specify <code>stripBaseDir</code> as a downloadSpecifier. This option is useful if you download zip files from eg. github tags, where they automatically put a container directory around the actual files. Eg. <code>--download-template=MyCustomGenerator:https://github/SI-Gen/SQLAlchemy.zip|stripBaseDir</code> The files will be downloaded to and unzipped in, to <code>&lt;template-location&gt;/&lt;freemarker_generator_name&gt;</code>. --template-generator -t FreeMarker-based generator to run.Format is : i.e. <code>--template-generator=MyCustomGenerator:./output</code>The template must exist as a directory under the location specified by --template-location. --builtin-postprocessor -bpp Built-In (Java-based) generatorName to run. Format is <code>&lt;generator_name&gt;:&lt;dest_dir&gt;</code> i.e. <code>--builtin-postprocessor=CSNetCode:./cs</code> --template-postprocessor -tpp FreeMarker-based post-processor to run.Format is : i.e. <code>--template-postprocessor=MyCustomGenerator:./output</code>The template must exist as a directory under the location specified by <code>--template-location</code>. --template-location -tl Freemarker template location. Default is <code>&lt;current_working_directory&gt;/jportal2_templates</code> --flag -F Flags to pass to the generator"},{"location":"Reference/column-types/","title":"Column types","text":"<p>JPortal2 SI files support the following column types for table fields, or proc parameters:</p> Type Description BLOB Binary Large Object BOOLEAN Boolean BYTE Byte or bytestringof length  CHAR Character or stringof length  DATE Date DATETIME DateTime DOUBLE Double DYNAMIC DynamicSQL - this type is an internal typeand not used by a user. FLOAT Floating point number IDENTITY INT Integer LONG Long Integer MONEY Money class, usually maps to the Decimal type SEQUENCE Auto-incrementing database sequence type, of size INT SHORT Short integer STATUS ? TIME Time TIMESTAMP Auto-inserted date-time. If you mark a column as TIMESTAMP, JPortal2will automatically insert the current date and time when you use a built-in INSERT or UPDATE PROC TLOB Text Large Object USERSTAMP Generally generator-specific, this maps in C# to the <code>cursor.GetUserStamp</code> function, and in most of the other generators simply maps to <code>CHAR</code> ANSICHAR Ansichar types UID GUID column-type XML XML column-type of max length 4,096 bytes BIGSEQUENCE Auto-incrementing database sequence type, of size BIGINT BIGIDENTITY AUTOTIMESTAMP Same as TIMESTAMP WCHAR Not used WANSICHAR Not used UTF8 Not used BIGXML XML column-type of max length 4,194,304 bytes JSON JSON column-type of max length 4,096 bytes BIGJSON JSON column-type of max length 4,194,304 bytes"},{"location":"Reference/configuration-file/","title":"Configuration file","text":"<p>You can specify a properties file using the <code>--properties-file</code> command-line parameter, to configure how JPortal2 must generate the output SQL syntax. The properties file supports the following entries:</p> <pre><code>TemplateOutputOptions.DatabaseNameSuffix=[\nTemplateOutputOptions.DatabaseNamePrefix=]\nTemplateOutputOptions.SchemaNamePrefix=[\nTemplateOutputOptions.SchemaNameSuffix=]\n\nTemplateOutputOptions.TableNamePrefix=[\nTemplateOutputOptions.TableNameSuffix=]\nTemplateOutputOptions.FieldNamePrefix=[\nTemplateOutputOptions.FieldNameSuffix=]\n\nTemplateOutputOptions.FieldVariablePrefix=:\nTemplateOutputOptions.FieldVariableSuffix=\n\nTemplateOutputOptions.EngineSugarPrefix=\nTemplateOutputOptions.EngineSugarSuffix=\nTemplateOutputOptions.EngineSugarSequence=default,\nTemplateOutputOptions.EngineSugarOutput=OUTPUT\nTemplateOutputOptions.EngineSugarTail=RETURNING\n\nTemplateOutputOptions.DynamicVariablePrefix={\nTemplateOutputOptions.DynamicVariableSuffix=}\n</code></pre>"},{"location":"Tutorials/adding-an-additional-table/","title":"Adding an additional table and foreign keys","text":"<p>Let's add a second table to our database. Create a file called <code>sql/si/todo_item.si</code>.  </p> <p>Your structure should now look like this: <pre><code>jportal2-demo\n\u2514\u2500\u2500\u2500sql\n    \u2514\u2500\u2500\u2500si\n        \u251c\u2500\u2500todolist.si\n        \u2514\u2500\u2500todo_item.si\n</code></pre></p> todo_items.si<pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDo_Item\nID               SEQUENCE\nTodoList_ID      INT     //This is a foreign key to the ToDoList table\nItemName         CHAR(255)\nItemDescription  CLOB\nLastUpdated      TIMESTAMP\n\n//This define ID as the Primary Key\nKEY PKEY PRIMARY\nID\n\nLINK ToDoList TodoList_ID\n\n//We do a normal Insert and Update without a Returning here, to test the regular generaion\n//We do an InsertReturning and UpdateReturning in the ToDoList table to test that generation there\nPROC Insert\nPROC Update\nPROC SelectOne\nPROC DeleteOne\n</code></pre> <p>Most of the file should be familiar to you now, but have a look at line 17: <pre><code>LINK ToDoList TodoList_ID```\n</code></pre></p> <p>The <code>LINK</code> keyword creates a foreign key. The syntax is <code>LINK &lt;parent_table&gt; &lt;my_column_name&gt;</code>. The line above instructs JPortal that there is a foreign key from <code>ToDoItem.TodeList_ID</code> to the primary key of <code>ToDoList</code>.</p>"},{"location":"Tutorials/additional-built-in-queries/","title":"Additional Built-In Queries","text":"<p>Now let's add 2 more queries to our table. This time we will do something a little more advanced than just a basic <code>SELECT</code> or <code>INSERT</code>.  </p> <p>Add the lines highlighted below:</p> todo_items.si<pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDo_Item\nID               SEQUENCE\nTodoList_ID      INT     //This is a foreign key to the ToDoList table\nItemName         CHAR(255)\nItemDescription  CLOB\nLastUpdated      TIMESTAMP\n\n//This define ID as the Primary Key\nKEY PKEY PRIMARY\nID\n\nLINK ToDoList TodoList_ID\n\n//We do a normal Insert and Update without a Returning here, to test the regular generaion\n//We do an InsertReturning and UpdateReturning in the ToDoList table to test that generation there\nPROC Insert\nPROC Update\nPROC SelectOne\nPROC DeleteOne\n\n//The SelectBy function automatically creates\n//a SELECT query using the given fields as the\n//WHERE clause\nPROC SelectBy TodoList_ID RETURNING ID ItemName ItemDescription LastUpdated\nPROC UpdateBy ItemName SET ItemDescription\n</code></pre> <p>We'll start with line 29: <pre><code>//The SelectBy function automatically creates\n//a SELECT query using the given fields as the\n//WHERE clause\nPROC SelectBy TodoList_ID RETURNING ID ItemName ItemDescription LastUpdated\n</code></pre></p> <p>This might look very a little weird, but it is actually really simple to understand. This simply creates a function that selects all the records from the Todo_Item table, for a specified TodoList_ID. In other words, this function will generate SQL similar to <pre><code>SELECT ID,\nItemName,\nItemDescription,\nLastUpdated\nFROM\nTodoList_Item\nWHERE\nTodoList_ID = &lt;SOME ID&gt;\n</code></pre></p> <p>Run <code>./generate_jportal.sh</code> again. Remember to run it from the terminal inside VSCode!  </p> <p>Search for a class named <code>DB_ToDo_ItemSelectByTodoList_ID</code>. You should see the following:</p> db_ToDo_Item.py<pre><code>@dataclass\nclass DB_ToDo_ItemSelectByTodoList_ID:\n    #Outputs\n    ID: int\n    ItemName: str\n    ItemDescription: str\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     , TodoList_ID: int\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \" OUTPUT (ID,ItemName,ItemDescription,LastUpdated)\"\n            tail = \" RETURNING ID ItemName ItemDescription LastUpdated\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDo_Item.SelectByTodoList_ID */\"\n                        f\"select\"\n                        f\"  ID\"\n                        f\", ItemName\"\n                        f\", ItemDescription\"\n                        f\", LastUpdated\"\n                        f\" from ToDoList_App.ToDo_Item\"\n                        f\" where TodoList_ID = :TodoList_ID\")\n\n        text_statement = statement.columns(ID=sa.types.Integer,\n                                      ItemName=db_types.NonNullableString,\n                                      ItemDescription=sa.types.Text,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        text_statement = text_statement.bindparams(TodoList_ID=TodoList_ID,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, TodoList_ID: int\n                     ) -&gt; List['DB_ToDo_ItemSelectByTodoList_ID']:\n        params = process_bind_params(session, [sa.types.Integer,\n                                        ], [TodoList_ID,\n                                        ])\n      PROC UpdateBy ItemName SET ItemDescription  res = session.execute(cls.get_statement(*params))\n        recs = res.fetchall()\n        return process_result_recs(DB_ToDo_ItemSelectByTodoList_ID, session, [sa.types.Integer,\n                                        db_types.NonNullableString,\n                                        sa.types.Text,\n                                        sa.types.DateTime,\n                                        ], recs)\n</code></pre> <p>Now look at line 31: <pre><code>PROC UpdateBy ItemName SET ItemDescription\n</code></pre></p> <p>You should start to see the pattern by now. We are creating an update statement that will update the ItemDescription for a given ItemName.</p> <p>Run <code>./generate_jportal.sh</code> and open the <code>db_ToDo_Item.py</code> file again. </p> <p>Now search for a class named <code>DB_ToDo_ItemUpdateByItemDescription</code>.  Look closely at the line highlighted below.</p> db_ToDo_Item.py<pre><code>@dataclass\nclass DB_ToDo_ItemUpdateByItemDescription:\n\n\n    @classmethod\n    def get_statement(cls\n                     , ItemDescription: str\n                     , LastUpdated: datetime\n                     , ItemName: str\n                     ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \"\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDo_Item.UpdateByItemDescription */\"\n                        f\"update ToDoList_App.ToDo_Item\"\n                        f\" set\"\n                        f\"  ItemDescription = :ItemDescription\"\nf\", LastUpdated = :LastUpdated\"\nf\" where ItemName = :ItemName\")\n\n        text_statement = statement.columns()\n        text_statement = text_statement.bindparams(ItemDescription=ItemDescription,\n                                         LastUpdated=LastUpdated,\n                                         ItemName=ItemName,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ItemDescription: str\n                     , LastUpdated: datetime\n                     , ItemName: str\n                     ) -&gt; None:\n        params = process_bind_params(session, [sa.types.Text,\n                                        sa.types.DateTime,\n                                        db_types.NonNullableString,\n                                        ], [ItemDescription,\n                                        LastUpdated,\n                                        ItemName,\n                                        ])\n        res = session.execute(cls.get_statement(*params))\n        res.close()\n</code></pre> <p>What's this? We specified that we wanted to update the ItemDescription. But the generated code is also updating  the <code>LastUpdated</code> field! Why is it doing that? Is the generation wrong?  </p> <p>No, actually this is a feature built into JPortal2. Look again at the table definition, specifically the column definition for LastUpdated. You will notice the columntype is specified as <code>TIMESTAMP</code>.  </p> <p>TIMESTAMP is a special type. When you specify a TIMESTAMP column, you are telling JPortal that you want this column to be updated every time you update the record. JPortal's generated INSERT statements will automatically put the current time into this column, as will the normal UPDATE. In this case, because we are doing a custom UPDATE, JPortal generates an input field that we must set when we call the function.</p>"},{"location":"Tutorials/creating-our-first-table-definition/","title":"Creating our first table definition","text":""},{"location":"Tutorials/creating-our-first-table-definition/#creating-our-first-simple-table-definition-todolist","title":"Creating our first simple table definition: ToDoList","text":""},{"location":"Tutorials/creating-our-first-table-definition/#create-the-si-file","title":"Create the SI file","text":"<p>Create a file called todolist.si in the ${rootDir}/sql/si directory created above. SI files are the input files to JPortal2.</p> <p>Your structure should now look like this: <pre><code>jportal2-demo\n\u2514\u2500\u2500\u2500.vscode\n    \u2514\u2500\u2500 settings.json\n\u2514\u2500\u2500\u2500sql\n    \u2514\u2500\u2500\u2500si\n        \u2514\u2500\u2500 todolist.si\n</code></pre></p> <p>The todolist.si file should contain the following code:</p> <p>todolist.si<pre><code>DATABASE ExampleDatabase\nPACKAGE com.example.db\nSERVER ExampleServer\nSCHEMA ToDoList_App\n\nTABLE ToDoList\nID               SEQUENCE\nListName         CHAR(255)\nListType         SHORT (Private=1, Public=2)\nDescription      CHAR(255)\nLastUpdated      TIMESTAMP\n\nKEY PKEY PRIMARY\nID\n\n//Simple CRUD queries are available out of the box with JPortal2\nPROC Insert Returning\nPROC Update\nPROC SelectOne\nPROC DeleteOne\n\n//You can put take-on or test data in this section\nSQLDATA\nINSERT INTO ToDoList_App.ToDoList(ListName,ListType,Description,LastUpdated) VALUES ('Takeon Test List 1', 1, 'Take on test list description', CURRENT_DATE );\nENDDATA\n\n&lt;Need to leave an empty line at the end&gt;**\n</code></pre> The above file does quite a lot, in a small amount of code:  </p> <ul> <li>Line 1 tells JPortal2 that you want to create a database called ExampleDatabase. Depending on the generator, this line may or may not be used.      </li> <li>Line 2 tells JPortal2 to put the code generated from this file, into a namespace/package called com.example.db  </li> <li>Line 3 tells JPortal2 that this code will be running in a microservice called ExampleServer. For the majority of your use cases, this is not important - this is really used for other private-source generators (not available to the public) that build off of JPortal2  </li> <li>Line 5-11 tells JPortal2 we want to create a database table called TodoList, with 5 fields, as well as the types of the fields. See  for a full list of field types supported. The only interesting thing to note here, is that we are defining the ListType field as a SHORT, but we are also specifying that we want an Enum for the field, which contains two values, \"Private\" and \"Public\". More on this later.   <li>Line 13-14 tells JPortal2 we want to create a key called PKEY. It will be of type <code>PRIMARY</code> (in other words a primary key) and consist of a single field, in this case the <code>ID</code> field.   </li> <li>Line 17-20 tells JPortal2 we want to generate code for 4 simple CRUD operations:  <ul> <li>an <code>Insert</code> function that will give us back the inserted primary key <code>ID</code> (because we specified the keyword <code>Returning</code>)</li> <li>An <code>Update</code> function that will take all the fields (except for the Primary Key), and update them.  </li> <li>A <code>SelectOne</code> function that selects a record by Primary Key, and returns all of the fields  </li> <li>A <code>DeleteOne</code> function that will delete a record by Primary Key</li> </ul> </li> <li>Line 22-25 is completely optional, but is a simple way to insert take-on data into our database for testing. It takes the lines that are between the tokens <code>SQLDATA</code> and <code>ENDDATA</code> and puts them verbatim into the generated files as we'll see below.</li> <p>Indenting and spacing generally doesn't matter, but try to indent to keep your code readable.</p> <p>Warning</p> <p>There is unfortunately one gotcha (bug) in JPortal2, you do need to have an empty line at the end  of your SI file. This is a side-effect of how our parser works, and seems to be an elusive bug to fix. So for now, just remember to leave an empty line at the end of your SI file. </p>"},{"location":"Tutorials/custom-queries/","title":"Custom Queries and Advanced functionality","text":"<p>The built-in Insert, Updates, Deletes, and various selects are cool, and you can do a lot with them.</p> <p>But what if you want to write a more complex query? JPortal2 makes that really easy too:</p> <p>Add the following code to the todo_item.si:</p> todo_item.si<pre><code>PROC GetItemsWithListNameForID\nINPUT\nID              =\nOUTPUT\nListName        CHAR(255)\nItemName        =\nItemDescription =\nSQLCODE\nSELECT  l.ListName,\ni.ItemName,\ni.ItemDescription\nFROM\nToDoList_App.ToDoList l INNER JOIN\nToDoList_App.ToDo_Item i\nON l.ID = i.TodoList_ID\nWHERE i.ID =  :ID\nENDCODE\n</code></pre> <p>This time, we need a bit more code, but it's still pretty simple. In line 1 we are defining the name for our custom proc. It will be called <code>GetItemsWithListNameForID</code>. Line 2-3 we are saying that our proc has a single input, called <code>ID</code>.  </p>"},{"location":"Tutorials/custom-queries/#the-equals-sign","title":"The <code>=</code> (equals sign)","text":"<p>You might be wondering what the <code>=</code> sign means in the above SI file.  </p> <p>Essentially, the <code>=</code> sign means \"use the column type specified in the table definition\".   </p> <p>Because ID is specified in our table as a SEQUENCE, the type for input parameter ID in our proc, will also be SEQUENCE.  </p> <p>Line 4-7 specifies the outputs of our proc. Here we are saying our proc will return a <code>ListName</code>, <code>ItemName</code> and <code>ItemDescription</code>.  </p> <p><code>ItemName</code> and <code>ItemDescription</code> are defined in our table defintion, so we can use the <code>=</code> sign trick  again.   </p> <p>But <code>ListName</code> is not defined in this file. Instead it is defined in the <code>todo_list.si</code> file.  </p> <p>JPortal2 only looks at the current SI file, so it doesn't know what column type to use for <code>ListName</code>. Therefore we specify it by hand as CHAR(255), which is the same as in the <code>todo_list.si</code> file.  </p> <p>Line 8-18 specifies our query that we want to run. Our code is specified between the keywords <code>SQLCODE</code> and <code>ENDCODE</code>. This indicates the start and end of our custom SQL to JPortal2.  </p> <p>Notice how we pass in the input parameter <code>ID</code>, using the syntax <code>:ID</code>. If you have more than one input parameter, you can refer to them by <code>:&lt;INPUT_PARAMETER_NAME&gt;</code>.</p>"},{"location":"Tutorials/custom-queries/#dynamic-sql","title":"Dynamic SQL","text":"<p>For our final trick, we will do something powerful, but dangerous.  For this, we will use dynamic sql: <pre><code>//Dynamic queries can be done with the ampersand below\n//REMEMBER!!! Dynamic SQL is open to SQL injection! So use with care and make sure to sanitize inputs!\n//Dynamic SQL is a last resort escape hatch, not the first tool to reach for!!\n//In the DAL class created for the below query, a property called ItemNamesList will be created\n//This will allow you to pass through the remainder of the where clause as a string.\nPROC SelectWithDynamicQuery\nINPUT\nID              =\nOUTPUT\nItemName        =\nItemDescription =\nLastUpdated     =\nSQLCODE\nSELECT\nItemName,\nItemDescription,\nLastUpdated\nFROM\nToDoList_App.ToDo_Item i\nWHERE\ni.ID = :ID\nAND\nItemName IN (&amp;ItemNamesList)\nENDCODE\n</code></pre></p> <p>If you run the jportal_generate.sh command again, you will see the following generated code:</p> ToDo_Item.py<pre><code>@dataclass\nclass DB_ToDo_ItemSelectWithDynamicQuery:\n    #Outputs\n    ItemName: str\n    ItemDescription: str\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                     , ID: int\n                     , ItemNamesList: str) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \" OUTPUT (ItemName,ItemDescription,LastUpdated)\"\n            tail = \" RETURNING ItemName ItemDescription LastUpdated\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n                        f\"/* PROC ToDoList_App.ToDo_Item.SelectWithDynamicQuery */\"\n                        f\"SELECT \"\n                        f\"ItemName, \"\n                        f\"ItemDescription, \"\n                        f\"LastUpdated \"\n                        f\"FROM \"\n                        f\"ToDoList_App.ToDo_Item i \"\n                        f\"WHERE \"\n                        f\"i.ID = :ID \"\n                        f\"AND \"\n                        f\"ItemName IN ( \"\n                        f\"{ItemNamesList}\"\n                        f\") \")\n\n        text_statement = statement.columns(ItemName=db_types.NonNullableString,\n                                      ItemDescription=sa.types.Text,\n                                      LastUpdated=sa.types.DateTime,\n                                      )\n        text_statement = text_statement.bindparams(ID=ID,\n                                         )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ID: int\n                     , ItemNamesList: str) -&gt; List['DB_ToDo_ItemSelectWithDynamicQuery']:\n        params = process_bind_params(session, [sa.types.Integer,\n                                        db_types.NonNullableString,], [ID,\n                                        ItemNamesList,])\n        res = session.execute(cls.get_statement(*params))\n        recs = res.fetchall()\n        return process_result_recs(DB_ToDo_ItemSelectWithDynamicQuery, session, [db_types.NonNullableString,\n                                        sa.types.Text,\n                                        sa.types.DateTime,\n                                        ], recs)\n</code></pre> <p>If you look at the generated code, you will see that it expects two input parameters, namely the <code>ID</code> we specified, but also <code>ItemNamesList</code>, which we specified on line 23 of the SI file.  </p> <p>Effectively, the dynamic sql clause (specified by an ampersand (&amp;) in the SI file), allows us to pass a text string through to our query. So if we wanted to query all ToDoItems named <code>A</code> and <code>B</code> related to ToDoList 123, we could do the following <pre><code>recs = DB_ToDo_ItemSelectWithDynamicQuery.execute(session, ID=123, \"'A','B'\")\n</code></pre></p> <p>Danger<p>While Dynamic SQL is very powerful, it is also very dangerous, because it opens you up to  SQL Injection Attacks. You should try to avoid using dynamic SQL as far possible. If you are forced to use is, make sure to guard against SQL injection by either coding against it, or using a library that helps with that.</p> </p>"},{"location":"Tutorials/generating-postgres-ddl/","title":"Generating PostgreSQL DDL","text":""},{"location":"Tutorials/generating-postgres-ddl/#generate-postgresql-ddl-from-our-si-file","title":"Generate PostgreSQL DDL from our SI file","text":"<p>Now, run the JPortal2 docker command, to generate a PostgreSQL DDL file:</p> <p>If you are running the tutorial inside a dev container as we recommend, make sure you open a terminal window in  VSCode, and run the below command in the built-in terminal. Opening a terminal in VSCode running a dev container, will  open the terminal inside the container, rather than on your local filesystem and OS.</p> generate_jportal.sh<pre><code>docker run --rm -v ${PWD}:/local ghcr.io/si-gen/jportal2:latest \\\n--inputdir=/local/sql/si \\\n--builtin-generator PostgresDDL:/local/generated_sources/generated_sql\n</code></pre> <p>Tip<p>For ease-of-use, we usually create a file named generate_jportal.sh in the root directory, which contains  the above command-line.</p> </p> <p>You will notice that we are passing 2 command-line parameters to JPortal2: The <code>--inputdir</code> parameter tells JPortal2 where the SI files are located. The <code>--builtin-generator</code> parameter tells JPortal2 that we want to run the built-in generator named PostgresDDL, and  place the generated output files in the directory <code>generated_sources/generated_sql</code></p> <p>After running the above command, you should see some console output, and then a freshly-generated file in the  <code>${rootDir}/generated_sources/generate_sql/</code> directory. The file will be named ExampleDatabase.sql (because we  specified the database name as <code>ExampleDatabase</code> in line one of the above SI file). The file should look as per below:</p> ExampleDatabase.sql<pre><code>DROP TABLE IF EXISTS ToDoList_App.ToDoList CASCADE;\n\nCREATE TABLE ToDoList_App.ToDoList\n( ID serial\n, ListName varchar(255)\n, ListType smallint\n, Description varchar(255)\n, LastUpdated timestamp\n);\n\nALTER TABLE ToDoList_App.ToDoList ALTER ID SET NOT NULL;\nALTER TABLE ToDoList_App.ToDoList ALTER ListName SET NOT NULL;\nALTER TABLE ToDoList_App.ToDoList ALTER ListType SET NOT NULL;\nALTER TABLE ToDoList_App.ToDoList ALTER Description SET NOT NULL;\nALTER TABLE ToDoList_App.ToDoList ALTER LastUpdated SET NOT NULL;\n\nALTER TABLE ToDoList_App.ToDoList\nADD CONSTRAINT TODOLIST_PKEY PRIMARY KEY\n( ID\n)\n;\n\nINSERT INTO ToDoList_App.ToDoList(ListName,ListType,Description,LastUpdated) VALUES ('Takeon Test List 1', 1, 'Take on test list description', CURRENT_DATE )\n</code></pre> <p>The above file should be completely self-explanatory, however we will add a few comments here: 1. The above DDL file is meant to facilitate easy creation of a local test database for developers. You will most  likely use it to create an initial test database to play with, but once you start getting into the proper SDLC,  and start creating DEV, QA and PROD database, you will use the file as an example or helper to write your own Flyway  or Liquibase scripts. It isn't meant to just use as-is in one of these tools. 2. Notice line 23, which contains the take-on data that we specified at the bottom of the todolist.si file above. As mentioned previously, this can be a quick and easy way to get test data into your database.</p>"},{"location":"Tutorials/generating-postgres-ddl/#create-our-tables-in-the-database","title":"Create our tables in the database","text":"<p>To run our DDL, we will use the VSCode SQLTools extension we installed here. Open the <code>generated_sources/generated_sql/ExampleDatabase.sql</code> file by double-clicking on it.</p> <p>Now press Ctrl+Shift+P to open the command palette, and type <code>SQLTools Run</code>, choose the <code>SQLTools Connection: Run this file</code> option: </p> <p>Finally, to check that our table was created, go to the SQLTools extension on the left, open the postgres connection, and navigate to the right schema and table:</p> <p></p> <p>Works like magic, doesn't it? :)</p> <p>\"OK, so we can generate DDL using the above mechanism,\" I hear you say, \"But what about the type-safe code you promised me? Where is all my Python, C#, or Java goodness? What is the point of this?\".</p> <p>Your point is completely valid - DDL is not hard to write, and you do it once. But you interact with the database from code every day. Fear not, we will get to that next.</p>"},{"location":"Tutorials/generating-python-code/","title":"Generate and use Python code","text":""},{"location":"Tutorials/generating-python-code/#generate-python-code","title":"Generate Python code","text":"<p>To generate Python code, we will make use of a JPortal template-generator named the <code>jportal2-generator-vanguard-sqlalchemy</code> template.</p> <p>Generators, specifically template generators, are a topic all on their own. You can read more about generators (including the difference between built-in and template generators) in &lt; TODO &gt;, but for now, just continue reading below, and follow the instructions. </p> <p>Type the following command: generate_jportal.sh<pre><code>docker run --rm -v ${SCRIPT_DIR}:/local ghcr.io/si-gen/jportal2:latest \\\n--inputdir=/local/sql/si \\\n--builtin-generator PostgresDDL:/local/generated_sources/generated_sql \\\n--template-generator SQLAlchemy:/local/generated_sources/python/jportal \\\n--download-template \"SQLAlchemy:https://github.com/SI-Gen/jportal2-generator-vanguard-sqlalchemy/archive/refs/tags/1.8.zip|stripBaseDir\"                      </code></pre></p> <p>You will notice that the command line looks very similar to the previous one we ran, to generate Postgres DDL, but it  has 2 additional lines.  </p> <p>Line 4 is very similar to line 3. It tells JPortal you want to run the template-generator named SQLAlchemy, and  place the generated output files in the directory <code>generated_sources/python/sqlalchemy</code>. The general format of the  command is <code>--template-generator &lt;GENERATOR_NAME&gt;:&lt;GENERATED_CODE_DESTINATION</code>.   line 5 is a little different. It tells JPortal where to find and download the SQLAlchemy generator we refer to in  line 4, from. For more information about using downloading template generators, and how and why you would want to do that, see &lt; TODO &gt;</p> <p>Now, navigate to the directory <code>generated_sources/python/jportal/sqlalchemy</code>. You should see a freshly generated file there, named <code>db_ToDoList.py</code>. This is the file that was generated by the SQLAlchemy generator. Let's have a look at the contents of the file:</p>"},{"location":"Tutorials/generating-python-code/#the-generated-python-code","title":"The generated python code","text":"<p>db_ToDoList.py<pre><code>########################################################################################################################\n################## Generated Code. DO NOT CHANGE THIS CODE. Change it in the generator and regenerate ##################\n########################################################################################################################\n\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import List, Any, Optional\nimport enum\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.sql.expression import TextAsFrom\n\nfrom .common.db_common import DBMixin, Base, DBColumn\nfrom .common import db_types\nfrom .common.processing import process_result_recs, process_result_rec, process_bind_params\n\n\n\n\n@dataclass\nclass DB_ToDoListInsertReturning:\n    # Enum for ListType field\n    class ListTypeEnum(enum.Enum):\n        Private = 1\n        Public = 2\n\n        @classmethod\n        def process_result_value_cls(cls, value, dialect):\n            return DB_ToDoListInsertReturning.ListTypeEnum(value)\n\n\n    #Outputs\n    ID: int\n\n    @classmethod\n    def get_statement(cls\n                      , ListName: str\n                      , ListType: ListTypeEnum\n                      , Description: str\n                      , LastUpdated: datetime\n                      ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \" RETURNING ID\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n            f\"/* PROC ToDoList_App.ToDoList.Insert */\"\n            f\"insert into ToDoList_App.ToDoList (\"\n            f\"  ID,\"\n            f\"  ListName,\"\n            f\"  ListType,\"\n            f\"  Description,\"\n            f\"  LastUpdated\"\n            f\" ) \"\n            f\"{_ret.output}\"\n            f\" values (\"\n            f\"{_ret.sequence}\"\n            f\"  :ListName,\"\n            f\"  :ListType,\"\n            f\"  :Description,\"\n            f\"  :LastUpdated\"\n            f\" )\"\n            f\"{_ret.tail}\")\n\n        text_statement = statement.columns(ID=sa.types.Integer,\n                                           )\n        text_statement = text_statement.bindparams(ListName=ListName,\n                                                   ListType=ListType,\n                                                   Description=Description,\n                                                   LastUpdated=LastUpdated,\n                                                   )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ListName: str\n                , ListType: ListTypeEnum\n                , Description: str\n                , LastUpdated: datetime\n                ) -&gt; Optional['DB_ToDoListInsertReturning']:\n        params = process_bind_params(session, [db_types.NonNullableString,\n                                               sa.types.SmallInteger,\n                                               db_types.NonNullableString,\n                                               sa.types.DateTime,\n                                               ], [ListName,\n                                                   ListType.value if isinstance(ListType, enum.Enum) else ListType,\n                                                   Description,\n                                                   LastUpdated,\n                                                   ])\n        res = session.execute(cls.get_statement(*params))\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_ToDoListInsertReturning, session, [sa.types.Integer,\n                                                                            ], rec)\n\n        return None\n\n@dataclass\nclass DB_ToDoListUpdate:\n    # Enum for ListType field\n    class ListTypeEnum(enum.Enum):\n        Private = 1\n        Public = 2\n\n        @classmethod\n        def process_result_value_cls(cls, value, dialect):\n            return DB_ToDoListUpdate.ListTypeEnum(value)\n\n\n\n\n    @classmethod\n    def get_statement(cls\n                      , ListName: str\n                      , ListType: ListTypeEnum\n                      , Description: str\n                      , LastUpdated: datetime\n                      , ID: int\n                      ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \"\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n            f\"update ToDoList_App.ToDoList\"\n            f\" set\"\n            f\"  ListName = :ListName\"\n            f\", ListType = :ListType\"\n            f\", Description = :Description\"\n            f\", LastUpdated = :LastUpdated\"\n            f\" where ID = :ID\")\n\n        text_statement = statement.columns()\n        text_statement = text_statement.bindparams(ListName=ListName,\n                                                   ListType=ListType,\n                                                   Description=Description,\n                                                   LastUpdated=LastUpdated,\n                                                   ID=ID,\n                                                   )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ListName: str\n                , ListType: ListTypeEnum\n                , Description: str\n                , LastUpdated: datetime\n                , ID: int\n                ) -&gt; None:\n        params = process_bind_params(session, [db_types.NonNullableString,\n                                               sa.types.SmallInteger,\n                                               db_types.NonNullableString,\n                                               sa.types.DateTime,\n                                               sa.types.Integer,\n                                               ], [ListName,\n                                                   ListType.value if isinstance(ListType, enum.Enum) else ListType,\n                                                   Description,\n                                                   LastUpdated,\n                                                   ID,\n                                                   ])\n        res = session.execute(cls.get_statement(*params))\n        res.close()\n\n@dataclass\nclass DB_ToDoListSelectOne:\n    # Enum for ListType field\n    class ListTypeEnum(enum.Enum):\n        Private = 1\n        Public = 2\n\n        @classmethod\n        def process_result_value_cls(cls, value, dialect):\n            return DB_ToDoListSelectOne.ListTypeEnum(value)\n\n\n    #Outputs\n    ListName: str\n    ListType: ListTypeEnum\n    Description: str\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                      , ID: int\n                      ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \" OUTPUT (ListName,ListType,Description,LastUpdated)\"\n            tail = \" RETURNING ListName ListType Description LastUpdated\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n            f\"/* PROC ToDoList_App.ToDoList.SelectOne */\"\n            f\"select\"\n            f\"  ListName\"\n            f\", ListType\"\n            f\", Description\"\n            f\", LastUpdated\"\n            f\" from ToDoList_App.ToDoList\"\n            f\" where ID = :ID\")\n\n        text_statement = statement.columns(ListName=db_types.NonNullableString,\n                                           ListType=sa.types.SmallInteger,\n                                           Description=db_types.NonNullableString,\n                                           LastUpdated=sa.types.DateTime,\n                                           )\n        text_statement = text_statement.bindparams(ID=ID,\n                                                   )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ID: int\n                ) -&gt; Optional['DB_ToDoListSelectOne']:\n        params = process_bind_params(session, [sa.types.Integer,\n                                               ], [ID,\n                                                   ])\n        res = session.execute(cls.get_statement(*params))\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_ToDoListSelectOne, session, [db_types.NonNullableString,\n                                                                      DB_ToDoListSelectOne.ListTypeEnum,\n                                                                      db_types.NonNullableString,\n                                                                      sa.types.DateTime,\n                                                                      ], rec)\n\n        return None\n\n@dataclass\nclass DB_ToDoListDeleteOne:\n\n\n    @classmethod\n    def get_statement(cls\n                      , ID: int\n                      ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \"\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n            f\"/* PROC ToDoList_App.ToDoList.DeleteOne */\"\n            f\"delete from ToDoList_App.ToDoList\"\n            f\" where ID = :ID\")\n\n        text_statement = statement.columns()\n        text_statement = text_statement.bindparams(ID=ID,\n                                                   )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ID: int\n                ) -&gt; None:\n        params = process_bind_params(session, [sa.types.Integer,\n                                               ], [ID,\n                                                   ])\n        res = session.execute(cls.get_statement(*params))\n        res.close()\n\n@dataclass\nclass DB_ToDoListSelectAll:\n    # Enum for ListType field\n    class ListTypeEnum(enum.Enum):\n        Private = 1\n        Public = 2\n\n        @classmethod\n        def process_result_value_cls(cls, value, dialect):\n            return DB_ToDoListSelectAll.ListTypeEnum(value)\n\n\n    #Outputs\n    ID: int\n    ListName: str\n    ListType: ListTypeEnum\n    Description: str\n    LastUpdated: datetime\n\n    @classmethod\n    def get_statement(cls\n                      ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \" OUTPUT (ID,ListName,ListType,Description,LastUpdated)\"\n            tail = \" RETURNING ID ListName ListType Description LastUpdated\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n            f\"/* PROC ToDoList_App.ToDoList.SelectAll */\"\n            f\"select\"\n            f\"  ID\"\n            f\", ListName\"\n            f\", ListType\"\n            f\", Description\"\n            f\", LastUpdated\"\n            f\" from ToDoList_App.ToDoList\")\n\n        text_statement = statement.columns(ID=sa.types.Integer,\n                                           ListName=db_types.NonNullableString,\n                                           ListType=sa.types.SmallInteger,\n                                           Description=db_types.NonNullableString,\n                                           LastUpdated=sa.types.DateTime,\n                                           )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session) -&gt; List['DB_ToDoListSelectAll']:\n        res = session.execute(cls.get_statement())\n        recs = res.fetchall()\n        return process_result_recs(DB_ToDoListSelectAll, session, [sa.types.Integer,\n                                                                   db_types.NonNullableString,\n                                                                   DB_ToDoListSelectAll.ListTypeEnum,\n                                                                   db_types.NonNullableString,\n                                                                   sa.types.DateTime,\n                                                                   ], recs)\n\n@dataclass\nclass DB_ToDoListStaticData:\n\n\n    @classmethod\n    def get_statement(cls\n                      ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \"\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n            f\"INSERT INTO ToDoList_App.ToDoList(ListName,ListType,Description,LastUpdated) VALUES ('Takeon Test List 1', 1, 'Take on test list description', CURRENT_DATE );\")\n\n        text_statement = statement.columns()\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session) -&gt; None:\n        res = session.execute(cls.get_statement())\n        res.close()\n</code></pre> Line 1-16 basically just sets up a bunch of imports required. Nothing fancy here. Line 20-75 is a bit more interesting. Let's have a look.</p>"},{"location":"Tutorials/generating-python-code/#insert-returning","title":"Insert Returning","text":"<pre><code>@dataclass\nclass DB_ToDoListInsertReturning:\n    # Enum for ListType field\n    class ListTypeEnum(enum.Enum):\n        Private = 1\n        Public = 2\n\n        @classmethod\n        def process_result_value_cls(cls, value, dialect):\n            return DB_ToDoListInsertReturning.ListTypeEnum(value)\n\n\n    #Outputs\n    ID: int\n\n    @classmethod\n    def get_statement(cls\n                      , ListName: str\n                      , ListType: ListTypeEnum\n                      , Description: str\n                      , LastUpdated: datetime\n                      ) -&gt; TextAsFrom:\n        class _ret:\n            sequence = \"default,\" #postgres uses default for sequences\n            output = \"\"\n            tail = \" RETURNING ID\"\n            #session.bind.dialect.name\n\n        statement = sa.text(\n            f\"/* PROC ToDoList_App.ToDoList.Insert */\"\n            f\"insert into ToDoList_App.ToDoList (\"\n            f\"  ID,\"\n            f\"  ListName,\"\n            f\"  ListType,\"\n            f\"  Description,\"\n            f\"  LastUpdated\"\n            f\" ) \"\n            f\"{_ret.output}\"\n            f\" values (\"\n            f\"{_ret.sequence}\"\n            f\"  :ListName,\"\n            f\"  :ListType,\"\n            f\"  :Description,\"\n            f\"  :LastUpdated\"\n            f\" )\"\n            f\"{_ret.tail}\")\n\n        text_statement = statement.columns(ID=sa.types.Integer,\n                                           )\n        text_statement = text_statement.bindparams(ListName=ListName,\n                                                   ListType=ListType,\n                                                   Description=Description,\n                                                   LastUpdated=LastUpdated,\n                                                   )\n        return text_statement\n\n    @classmethod\n    def execute(cls, session: Session, ListName: str\n                , ListType: ListTypeEnum\n                , Description: str\n                , LastUpdated: datetime\n                ) -&gt; Optional['DB_ToDoListInsertReturning']:\n        params = process_bind_params(session, [db_types.NonNullableString,\n                                               sa.types.SmallInteger,\n                                               db_types.NonNullableString,\n                                               sa.types.DateTime,\n                                               ], [ListName,\n                                                   ListType.value if isinstance(ListType, enum.Enum) else ListType,\n                                                   Description,\n                                                   LastUpdated,\n                                                   ])\n        res = session.execute(cls.get_statement(*params))\n        rec = res.fetchone()\n        if rec:\n            res.close()\n            return process_result_rec(DB_ToDoListInsertReturning, session, [sa.types.Integer,\n                                                                            ], rec)\n\n        return None\n</code></pre> <p>Now this is a lot more interesting. We are declaring a class called DB_ToDoListInsertReturning, but it has several  member fields and methods.  </p> <p>The first thing we notice, is that on line 23-29, we generate an Enum called ListTypeEnum. Remember how when we created the SI file, we created the field ListType as a SHORT, but we specified that we wanted an enum with two value,  \"Public\" and \"Private\"? The SQLAlchemy generator picked that up, and generated an enum for us, to use in our code.  For more information about enums, see &lt; TODO &gt;.</p> <p>Next, on line 32-33 we specify that this class has an OUTPUT member ID. In JPortal2, database operations can  have INPUT and/or OUTPUT fields. Input fields are obviously fields you pass into the class, before it interacts with  the database. Output fields are fields we want to get back from the database.</p> <p>In this case, remember we specified that we wanted JPortal to create an Insert function for us, specifically  an Insert Returning, which would return the Primary Key after inserting? In this table, ID is the primary key,  so the Insert Returning must return the ID field for us.</p> <p>Let's move on the rest of the file.  </p> <p>Line 35-74 is a method called get_statement. If you look over the code, you will see it basically creates an inline  SQL statement that allows you to insert an entire ToDoList record. Most of it is probably very straightforward,  but you may be confused by the lines that contain \"_ret.\". Don't worry about it too much. For now, just accept that  this is required because different databases like Postgres, SQLServer, Oracle, DB/2 etc. all have slightly varying  syntaxes, and this allows us to cater for differences at runtime.</p> <p>Finally, we get to line 97-98. This is a method called execute(), which does exactly what it says, it executes  the query defined above in get_statement, and reads back the inserted ID field that was returned.</p> <p>We aren't going to go through the the remainder of the generated code, because it is all essentially a repetition of  lines 20-98, albeit for the other built-in queries we wanted, i.e. Update, SelectOne, DeleteOne and finally  SelectAll.</p>"},{"location":"Tutorials/generating-python-code/#interact-with-our-database-using-python","title":"Interact with our database using Python","text":"<p>Now that we have our Data Access Layer (DAL) defined, let's write a quick python program to use is.</p> <p>Create a file called <code>python/jportal_example.py</code>. Your folder structure should now look like this: <pre><code>jportal2-demo\n\u2514\u2500\u2500\u2500.vscode\n    \u2514\u2500\u2500 settings.json\n\u2514\u2500\u2500\u2500sql\n    \u2514\u2500\u2500\u2500si\n        \u2514\u2500\u2500 todolist.si\n\u2514\u2500\u2500\u2500python\n    \u2514\u2500\u2500 jportal_example.py\n</code></pre></p>"},{"location":"Tutorials/generating-python-code/#selectall","title":"SelectAll","text":"<p>Paste the following code into the file: <pre><code>from datetime import datetime\nimport sys\nfrom jportal import sqlalchemy as jportal\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import Session\n\nengine = sa.create_engine(\"postgresql+psycopg2://postgres:magic_password@localhost/postgres\")\n\nsession = Session(engine)\n\n### ToDoList ###\n#Select All\ndef select_all_from_todo_list(session):\n    recs = jportal.DB_ToDoListSelectAll.execute(session)\n    for rec in recs:\n        print(f\"ID: {rec.ID}\")\n        print(f\"ListName: {rec.ListName}\")\n        print(f\"ListType: {rec.ListType}\")\n        print(f\"Description: {rec.Description}\")\n        print(\"***\")\n\n\nselect_all_from_todo_list(session)\nsession.rollback() #For the demo, normally you'd call session.commit() here\n</code></pre></p> <p>Let's look at it piece by piece: Line 1-5 simply imports the required modules. We import our generated code as <code>jportal</code>. Then we import sqlalchemy. SQLAlchemy is a popular ORM for Python. We actually don't like ORM's, we feel they add  unnecessary complications to development. We feel that plain old SQL is far easier to read/write/debug and understand. That said, SQLAlchmey does some useful things, like connection pooling. So as a result, we use the SQLAlchemy session  management as a base library, and build our generated classes on top of it.</p> <p>Line 7 simply opens a SQLAlchemy connection to our postgres database. The username and password are created when we start the docker container inside <code>start_postgres.sql</code>.  </p> <p>Line 11-20 we create a simple function that calls our generated <code>SelectAll</code> function. <code>SelectAll</code> simply returns all the records in a table. In reality, you almost never want to return all the records in a table unless it is a small lookup table, but for our demo, <code>SelectAll</code> is useful.</p> <p>On line 23 we call the function we defined up top, and on line 24 we simply rollback the SQLAlchemy connection to avoid a warning when we exit the program.</p> <p>Save the file. Assuming you are using our dev container repo, you can either press F5 to execute the program, or use the normal VSCode run mechanism. If you are not using our dev container, you can run the code using  <code>python jportal_example.py</code>, but bear in mind you will need to add the <code>generated_code/python/jportal</code> folder to the  PYTHONPATH, and also install the requirements defined in <code>python/requirements.txt</code>. We are not going to talk through that in this tutorial.</p> <p>Once you run the example program, you should see the following output: <pre><code>ID: 1\nListName: Takeon Test List 1\nListType: ListTypeEnum.Private\nDescription: Take on test list description\n***\n</code></pre></p> <p>You might recognise this as the data we added in our SI file in the <code>SQLDATA</code> section, and which was inserted when we  ran the <code>ExampleDatabase.sql</code> DDL script.</p> <p>How easy was that?</p>"},{"location":"Tutorials/generating-python-code/#insert-returning_1","title":"Insert Returning","text":"<p>Let's test the rest of the generated code. Change <code>jportal_example.py</code> to look like this:</p> <pre><code>from datetime import datetime\nimport sys\nprint(\"PYTHONPATH=\",sys.path)\nfrom jportal import sqlalchemy as jportal\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import Session\n\nengine = sa.create_engine(\"postgresql+psycopg2://postgres:magic_password@localhost/postgres\")\n\n\n\nsession = Session(engine)\n\n### ToDoList ###\n#Select All\ndef select_all_from_todo_list(session):\n    recs = jportal.DB_ToDoListSelectAll.execute(session)\n    for rec in recs:\n        print(f\"ID: {rec.ID}\")\n        print(f\"ListName: {rec.ListName}\")\n        print(f\"ListType: {rec.ListType}\")\n        print(f\"Description: {rec.Description}\")\n        print(\"***\")\n\n### ToDoList ###\n#Insert Returning\ndef insert_returning_todo_list(session):\n    #Insert\n    tdl_ret = jportal.DB_ToDoListInsertReturning.execute(session, \n                                                        \"New List\", \n                                                        jportal.DB_ToDoListInsertReturning.ListTypeEnum.Private,\n                                                        \"Some Description\",\n                                                        datetime.now())\n\n    return tdl_ret\n\n\nselect_all_from_todo_list(session)\n\ntdl_ret = insert_returning_todo_list(session)\nprint(f\"Added record {tdl_ret.ID} into ToDoList\")\n\nselect_all_from_todo_list(session)\n\nsession.rollback() #For the demo, normally you'd call session.commit() here\n</code></pre> <p>On line 29 we insert a new record into the ToDoList table: - We name the list \"New List\" - We set the ListType as \"Private\". Notice how we can use the generated enum to set this! - We add a simple description field. -  Finally we set the TMStamp field to the current time.  </p> <p>Once we have done the insert, we call our select_all function again, to see the record we added.</p> <p>Run the program again. Now the output should look something like this: <pre><code>ID: 1\nListName: Takeon Test List 1\nListType: ListTypeEnum.Private\nDescription: Take on test list description\n***\nAdded record 2 into ToDoList\nID: 1\nListName: Takeon Test List 1\nListType: ListTypeEnum.Private\nDescription: Take on test list description\n***\nID: 2\nListName: New List\nListType: ListTypeEnum.Private\nDescription: Some Description\n***\n</code></pre></p>"},{"location":"Tutorials/generating-python-code/#selectone-and-update","title":"SelectOne and Update","text":"<p>Finally, change the <code>jportal_example.py</code> file to look like this: <pre><code>from datetime import datetime\nimport sys\nprint(\"PYTHONPATH=\",sys.path)\nfrom jportal import sqlalchemy as jportal\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import Session\n\nengine = sa.create_engine(\"postgresql+psycopg2://postgres:magic_password@localhost/postgres\")\n\n\n\nsession = Session(engine)\n\n### ToDoList ###\n#Select All\ndef select_all_from_todo_list(session):\n    recs = jportal.DB_ToDoListSelectAll.execute(session)\n    for rec in recs:\n        print(f\"ID: {rec.ID}\")\n        print(f\"ListName: {rec.ListName}\")\n        print(f\"ListType: {rec.ListType}\")\n        print(f\"Description: {rec.Description}\")\n        print(\"***\")\n\n### ToDoList ###\n#Insert Returning\ndef insert_returning_todo_list(session):\n    #Insert\n    tdl_ret = jportal.DB_ToDoListInsertReturning.execute(session, \n                                                        \"New List\", \n                                                        jportal.DB_ToDoListInsertReturning.ListTypeEnum.Private,\n                                                        \"Some Description\",\n                                                        datetime.now())\n\n    return tdl_ret\n\n### ToDoList ###\n#Select One\ndef select_one_from_todo_list(session):\n    rec = jportal.DB_ToDoListSelectOne.execute(session,1)\n    print(f\"ListName: {rec.ListName}\")\n    print(f\"ListType: {rec.ListType}\")\n    print(f\"Description: {rec.Description}\")\n    print(\"***\")\n\n### ToDoList ###\n#Select All\ndef update_todo_list(session):\n    recs = jportal.DB_ToDoListUpdate.execute(session,\n                                                \"Updated ListName\",\n                                                jportal.DB_ToDoListUpdate.ListTypeEnum.Private,\n                                                \"Updated description\",\n                                                datetime.now(),\n                                                1)\n\nselect_all_from_todo_list(session)\n\ntdl_ret = insert_returning_todo_list(session)\nprint(f\"Added record {tdl_ret.ID} into ToDoList\")\n\nselect_one_from_todo_list(session)\nupdate_todo_list(session)\nselect_all_from_todo_list(session)\n\n\n\n\nsession.rollback() #For the demo, normally you'd call session.commit() here\n</code></pre></p> <p>Run it again. The output should look something like this now (the ID's might be slightly different depending on how  many times you ran it, because of the behaviour of the SEQUENCE datatype):</p> <pre><code>ListName: Takeon Test List 1\nListType: ListTypeEnum.Private\nDescription: Take on test list description\n***\nID: 5\nListName: New List\nListType: ListTypeEnum.Private\nDescription: Some Description\n***\nID: 1\nListName: Updated ListName\nListType: ListTypeEnum.Private\nDescription: Updated description\n***\n</code></pre>"},{"location":"Tutorials/generating-python-code/#summary","title":"Summary","text":"<p>At this point, take a step back and consider the power of JPortal2. If you look at our initial SI file, you will see that in 17 lines, we defined a database, a schema, a table with 5 fields, and a complex insert statement. Using these 17 lines we generated nearly 20 lines of Postgres Specific DDL, and over a 100 lines of Python code. That is a huge amount of code you didn't need to write or think about.</p>"},{"location":"Tutorials/getting-started/","title":"Setting up your tutorial environment","text":"<p>For this tutorial, we recommend using VSCode. You can use any editor, but VSCode is a free, platform-independent editor with a rich ecosystem of plugins and functionality, specifically a JPortal2 plugin which gives code completion and syntax highlighting. Furthermore, VSCode supports the concept of Dev Containers.</p> <p>A Dev Container allows us to very easily set up a dev environment on a local dev machine, on any OS, by making use of  containers.</p> <p>We have created a VSCode project for this tutorial, which includes a dev container. The dev container is preconfigured  with all the tools and extensions needed to complete this tutorial, as well as all the files created in the following  tutorial sections. We strongly recommend you just clone the tutorial repo below, and use that.</p> <p>If you absolutely insist on doing things manually, you can follow along with the instructions, but you may run into issues if you have typos or misread the instructions. Caveat Emptor!</p>"},{"location":"Tutorials/getting-started/#cloning-the-tutorial-repo-aka-the-easy-way","title":"Cloning the tutorial repo (aka \"The Easy Way\")","text":"<p>By far the easiest way to get started, is to just clone the tutorial repo at  https://github.com/SI-Gen/jportal2-quickstart</p> <pre><code>git clone https://github.com/SI-Gen/jportal2-quickstart.git\ncd jportal2-quickstart\ncode .\n</code></pre> <p>The finally line <code>code .</code> tells VSCode to open the current directory.  </p> <p>VSCode will start, and in all likelihood detect that the directory contains a dev container definition. If you don't  already have the Dev Container extension installed, it will ask to install it, say yes.</p> <p>Once the Dev Container extension is installed, VSCode will usually ask if you want to open the project in a container.  If it doesn't, press Ctrl+Shift+P to open the command palette and start typing <code>open folder</code>. Choose the option  <code>Dev Containers: Open folder in container</code> once it comes up.  </p> <p></p> <p>VS Code will download and build the dev container (if this is the first time you are running the tutorial). Then it will restart and your project will be opened via the dev container. VSCode may also ask to install the relevant  extensions. Say yes for all of them.</p> <p>There! You're done! Skip the rest of this section!</p>"},{"location":"Tutorials/getting-started/#do-it-manually-aka-the-hard-way","title":"Do it manually (aka \"The Hard Way\")","text":""},{"location":"Tutorials/getting-started/#installing-jportal2-vscode-and-languagess-and-databases","title":"Installing JPortal2, VSCode and languagess and databases","text":"<p>This tutorial assumes that the latest version of JPortal2 is installed  and ready to use, via the cross-platform Docker image. It also assumes you've installed the JPortal VSCode plugin Lastly it assumes you have all the required databases and languages installed, depending on which languages and  databases you want to work with in the tutorial. We will not be talking you through how to install Postgres, SQL Server, C#, Python etc in this tutorial. </p>"},{"location":"Tutorials/setting-up-the-project-directory-and-database/","title":"Setup the project directory","text":"<p>Now we are ready to create our project.   </p>"},{"location":"Tutorials/setting-up-the-project-directory-and-database/#directory-setup","title":"Directory setup","text":"<p>Create a new directory called <code>jportal2-demo</code>. This will be the root directory of your project.  </p> <p>Inside the root directory, create directories called <code>sql/si</code>. The name of this directory is completely up to you, you can put JPortal files anywhere you want in your project, but to make the demo easier to follow, we suggest following our structure.  </p> <p>Your directory structure should now look like this: <pre><code>jportal2-demo\n\u2514\u2500\u2500\u2500sql\n    \u2514\u2500\u2500\u2500si\n</code></pre></p>"},{"location":"Tutorials/setting-up-the-project-directory-and-database/#postgres-database-setup","title":"Postgres database setup","text":"<p>Next create a file called start_postgres.sh, with the contents below:</p> <p>start_postgres.sh <pre><code>docker run --name postgres -e POSTGRES_PASSWORD=magic_password postgres\n</code></pre></p> <p>make this script executable via <code>chmod +x start_postgres.sh</code>, then run it in a terminal window. You should see a bunch  of scrolling text output, and finally the text  </p> <p><code>database system is ready to accept connections</code> </p> <p>Once you see this, it means postgres is up an running.</p>"},{"location":"Tutorials/setting-up-the-project-directory-and-sqltools-extension/","title":"Setting up our project directory & installing the SQLTools extension","text":""},{"location":"Tutorials/setting-up-the-project-directory-and-sqltools-extension/#setup-the-project-directory","title":"Setup the project directory","text":"<p>You can read through this section for background if you cloned the tutorial repo, but all of the below steps have  been done for you.</p>"},{"location":"Tutorials/setting-up-the-project-directory-and-sqltools-extension/#directory-setup","title":"Directory setup","text":"<p>Now we are ready to create our project.</p> <p>Create a new directory called <code>jportal2-tutorial</code>. This will be the root directory of your project.  </p> <p>Inside the root directory, create directories called <code>sql/si</code>. The name of this directory is completely up to you, you can put JPortal files anywhere you want in your project, but to make the demo easier to follow, we suggest following our structure.  </p> <p>Your directory structure should now look like this: <pre><code>jportal2-tutorial\n\u2514\u2500\u2500\u2500sql\n    \u2514\u2500\u2500\u2500si\n</code></pre></p>"},{"location":"Tutorials/setting-up-the-project-directory-and-sqltools-extension/#installing-the-sqltools-extension","title":"Installing the SQLTools extension","text":"<p>To interact with our test databases, we need an admin tool. There are many available and you can use any one you like, but to keep this tutorial simple and standard, we're going to install a VSCode extension called SQLTools.</p> <p>To install the SQLTools extension, choose the Extensions tab on the left (Or press Ctrl-P and type \"install extensions\"). Type \"SQLTools\" into the search field, choose the <code>SQLTools</code> extension (the one by Mattheus Teixeira), and install it. Also install the <code>SQLTools PostgreSQL/Cockroach/Redshift Driver</code> extension if you plan to use Postgres, as well as the additional <code>SQLTools Microsoft SQL Server/Azure Driver</code> if you want to use SQL Server.</p> <p>See the video below:</p> <p></p> <p>Now, let's set up a file which contains the connection info to a local postgres database. Create a directory called .vscode and in there, create a file called settings.json</p> <p>.vscode/settings.json <pre><code>{\n\"sqltools.connections\": [\n{\n\"previewLimit\": 50,\n\"server\": \"localhost\",\n\"port\": 5432,\n\"driver\": \"PostgreSQL\",\n\"name\": \"jportal_postgres\",\n\"database\": \"postgres\",\n\"username\": \"postgres\",\n\"password\": \"magic_password\"\n}\n]\n}\n</code></pre></p> <p>Your directory structure should now look like this: <pre><code>jportal2-tutorial\n\u2514\u2500\u2500\u2500.vscode\n    \u2514\u2500\u2500 settings.json\n\u2514\u2500\u2500\u2500sql\n    \u2514\u2500\u2500\u2500si\n</code></pre></p>"},{"location":"Tutorials/summary/","title":"Summary","text":"<p>You have now completed the JPortal2 tutorial. Well done!</p> <p>Let's recap what we covered in this tutorial: 1. You learnt how to create a simple table, and generate basic CRUD queries like <code>Insert</code>, <code>Update</code>, <code>SelectOne</code> and  <code>DeleteOne</code>. You also learnt how to insert test data into your database. 2. You learnt how to generate Postgres DDL, using the built-in Postres DDL generator. 3. You learnt how to generate Python code, using the SQLAlchmemy template generator. 4. Next you learnt how to create foreign keys, and how to write a more complex select query using <code>SelectBy</code>. 5. Lastly you learnt how to write your own custom queries, and also how to use dynamic SQL to do things that you can't otherwise do using parameterised SQL.  </p> <p>We hope you enjoyed working through this tutorial, and you see the power that is available to you when you use it. Here's hoping you keep using it on your projects!</p>"},{"location":"generators/","title":"Index","text":"<p>Documentation for each generator:</p>"},{"location":"generators/#ddl-generators","title":"DDL Generators","text":"<p>Generation has changed to now generate a single file for each table that contains that table only and then generate the sequences.sql, views.sql and foreign_keys.sql files separately.</p> <p>In order to utilize single file generation for DDL generators, pass the flag SingleFileDDLGeneration to the run of the program. An example is as follows:</p> <pre><code>docker run --rm -v ${PWD}:/local ghcr.io/si-gen/jportal2:latest \\\n--inputdir=/local/sql/si \\\n--builtin-generator PostgresDDL:/local/generated_sources/generated_sql \\\n--flag SingleFileDDLGeneration                    </code></pre> <p>MSSqlDDL - DDL Generator for Microsoft SQL Server</p>"},{"location":"generators/MSSqlDDL/","title":"MSSqlDDL","text":"Generator name Generator Output Output file extension Freemarker or Java Builtin MSSqlDDL Script SI file as Database Definition .sql Java True"},{"location":"generators/MSSqlDDL/#supported-types","title":"Supported types","text":"<p>All SI types can be appended with <code>NULL</code>, for example <code>COLNAME &lt;DB TYPE&gt; NULL</code>, to make the field nullable. If <code>NULL</code> has NOT been specified the field will generate as: <code>COLNAME &lt;DB TYPE&gt; NOT NULL</code></p> SI Type Database Type Condition SI Example Generated Example CHAR(\\) VARCHAR(\\) \\ &lt;= 8000 CHAR(500) VARCHAR(500) CHAR(\\) VARCHAR(MAX) \\ &gt; 8000 CHAR(9000) VARCHAR(MAX) ANSICHAR(\\) CHAR(\\) ANSICHAR(500) CHAR(500) BOOLEAN BIT BOOLEAN BIT BYTE TINYINT BYTE TINYINT SHORT SMALLINT SHORT SMALLINT INT INT INT INT LONG BIGINT LONG BIGINT FLOAT FLOAT FLOAT FLOAT FLOAT(\\, \\) FLOAT \\ &lt;= 15 FLOAT(10, 10) FLOAT FLOAT(\\, \\) DECIMAL(\\, \\) \\ &gt; 15 FLOAT(20, 10) DECIMAL(20, 10) DOUBLE FLOAT DOUBLE FLOAT DOUBLE(\\, \\) FLOAT \\ &lt;= 15 DOUBLE(10, 10) FLOAT DOUBLE(\\, \\) DECIMAL(\\, \\) \\ &gt; 15 DOUBLE(20, 10) IDENTITY INTEGER IDENTITY(1,1) IDENTITY INTEGER IDENTITY(1,1) BIGIDENTITY BIGINT IDENTITY(1,1) BIGIDENTITY BIGINT IDENTITY(1,1) SEQUENCE INTEGER hasSequenceReturning == False SEQUENCE INTEGER SEQUENCE INTEGER IDENTITY(1,1) hasSequenceReturning == True SEQUENCE INTEGER IDENTITY(1,1) BIGSEQUENCE BIGINT hasSequenceReturning == False BIGSEQUENCE BIGINT BIGSEQUENCE BIGINT IDENTITY(1,1) hasSequenceReturning == True BIGSEQUENCE BIGINT IDENTITY(1, 1) DATE DATETIME DATE DATETIME DATETIME DATETIME DATETIME DATETIME BLOB IMAGE BLOB IMAGE BIGXML XML BIGXML XML XML XML XML XML MONEY MONEY MONEY MONEY USERSTAMP VARCHAR(50) USERSTAMP VARCHAR(50) UID UNIQUEIDENTIFIER UID UNIQUEIDENTIFIER undefined SI type unkown * unknown <p>The <code>hasSequenceReturning</code> variable is <code>False</code> by defualt and is set to <code>True</code> if the standard INSERT proc has the RETURNING keyword: <pre><code>PROC INSERT RETURNING\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#automatic-adding-of-fields","title":"Automatic Adding of Fields","text":""},{"location":"generators/MSSqlDDL/#tmstamp","title":"TmStamp","text":"<p>The TmStamp field can automatically be added to the table by specifying the <code>--flag \"add timestamp\"</code> flag: <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n    USER_ID             USERSTAMP\n</code></pre> Jportal Params: <pre><code>--builtin-generator MSSqlDDL:\\tmp --flag \"add timestamp\"\n</code></pre> Example output: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER IDENTITY(1,1) NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, USER_ID VARCHAR(50) NOT NULL\n, TIMESTAMP\n, CONSTRAINT PK_ExampleSchema_Example_PKEY PRIMARY KEY (\n    ID\n  )\n)\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#userid-and-tmstamp","title":"UserId and TmStamp","text":"<p>UserId's and TmStamp fields can automatically be added to the table by specifing <code>--flag \"internal stamps\"</code> to the generator. <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n</code></pre> Jportal Params: <pre><code>--builtin-generator MSSqlDDL:\\tmp --flag \"internal stamps\"\n</code></pre> Example output: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER IDENTITY(1,1) NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, UpdateWhen  DATETIME DEFAULT CURRENT_TIMESTAMP NULL\n, UpdateByWho CHAR(8)  DEFAULT USER NULL \n, CONSTRAINT PK_ExampleSchema_Example_PKEY PRIMARY KEY (\n    ID\n  )\n)\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#triggers","title":"Triggers","text":""},{"location":"generators/MSSqlDDL/#insert-trigger","title":"Insert trigger","text":"<p>An insert trigger can be used to automatically set <code>ID</code>, <code>TIMESTAMP</code> and <code>USERSTAMP</code> fields. In order for this to generate in the DDL you need to specify the Primary key of type <code>SEQUENCE</code> or <code>BIGSEQUENCE</code> and pass the <code>--flag \"use insert trigger\"</code> to the generator:</p> <p>Example si file: <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n    USER_ID             USERSTAMP\n    TMSTAMP             TIMESTAMP\n</code></pre> Jportal Params: <pre><code>--builtin-generator MSSqlDDL:\\tmp --flag \"use insert trigger\"\n</code></pre></p> <p>This will generate the DDL: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, USER_ID VARCHAR(50) NOT NULL\n, TMSTAMP DATETIME NOT NULL\n, CONSTRAINT PK_ExampleSchema_Example_PKEY PRIMARY KEY (\n    ID\n  )\n)\nGO\n\nIF OBJECT_ID('ExampleSchema.ExampleInsertTrigger','TR') IS NOT NULL\n    DROP TRIGGER ExampleSchema.ExampleInsertTrigger\nGO\n\nCREATE TRIGGER ExampleSchema.ExampleInsertTrigger ON ExampleSchema.Example FOR INSERT AS\nUPDATE ExampleSchema.Example SET ID=ID+0\nWHERE ID=(SELECT MAX(ID) FROM ExampleSchema.Example)\nUPDATE ExampleSchema.Example\nSET\n  ID = (SELECT MAX(ID) FROM ExampleSchema.Example)+1\n, USER_ID = USER_NAME()\n, TMSTAMP = GETDATE()\nWHERE ID = (SELECT ID FROM INSERTED)\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#audit-trigger","title":"Audit Trigger","text":"<p>An Audit trigger can be generated to track <code>INSERT</code>, <code>DELETE</code> and <code>UPDATE</code> queries performed on the table. For this to happed the flag <code>--flag \"audit triggers\"</code> should be passed to the generator. If the flag is passed a secondry table will be generated in the DDL called <code>&lt;SCHEMA&gt;&lt;TABLENAME&gt;Audit</code>. When an <code>INSERT</code>, <code>UPDATE</code> or <code>DELETE</code> query is executed this table will be inserted into with: <pre><code>ACTION\nGETDATE()\n&lt;TABLE FIELDS&gt;\n</code></pre> Example SI file: <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n    USER_ID             USERSTAMP\n    TMSTAMP             TIMESTAMP\n</code></pre> Jportal Params: <pre><code>--builtin-generator MSSqlDDL:E:\\temp --flag \"audit triggers\"\n</code></pre> This will generate the DDL: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, USER_ID VARCHAR(50) NOT NULL\n, TMSTAMP DATETIME NOT NULL\n, CONSTRAINT PK_ExampleSchema_Example_PKEY PRIMARY KEY (\n    ID\n  )\n)\nGO\n\nIF OBJECT_ID('ExampleSchema.ExampleUpdateTrigger','TR') IS NOT NULL\n    DROP TRIGGER ExampleSchema.ExampleUpdateTrigger\nGO\n\nCREATE TRIGGER ExampleSchema.ExampleUpdateTrigger ON ExampleSchema.Example FOR UPDATE AS\nUPDATE ExampleSchema.Example\nSET\n  USER_ID = USER_NAME()\n, TMSTAMP = GETDATE()\nFROM INSERTED I\nWHERE ExampleSchema.ExampleID = I.ID \nGO\n\nIF OBJECT_ID('ExampleSchemaExampleAudit','U') IS NOT NULL\n    DROP TABLE ExampleSchemaExampleAudit\nGO\n\nCREATE TABLE ExampleSchemaExampleAudit\n(\n  AuditId INTEGER IDENTITY(1,1) NOT NULL PRIMARY KEY\n, AuditAction INTEGER NOT NULL -- 1 = INSERT, 2 = DELETE, 3 = UPDATE\n, AuditWhen DATETIME NOT NULL\n, ID INTEGER NULL\n, SOME_DATA VARCHAR(100) NULL\n, USER_ID VARCHAR(50) NULL\n, TMSTAMP DATETIME NULL\n)\nGO\n\nIF OBJECT_ID('ExampleSchemaExampleAuditTrigger','TR') IS NOT NULL\n    DROP TRIGGER ExampleSchemaExampleAuditTrigger\nGO\n\nCREATE TRIGGER ExampleSchemaExampleAuditTrigger ON ExampleSchemaExample\nFOR INSERT, DELETE, UPDATE AS\nBEGIN\n  DECLARE @INSERT INT, @DELETE INT, @ACTION INT;\n  SELECT @INSERT = COUNT(*) FROM INSERTED;\n  SELECT @DELETE = COUNT(*) FROM DELETED;\n  IF @INSERT &gt; 0 SELECT @ACTION = 1 ELSE SELECT @ACTION = 0;\n  IF @DELETE &gt; 0 SELECT @ACTION = @ACTION + 2;\n  -- 1 = INSERT, 2 = DELETE, 3 = UPDATE\n  IF @ACTION = 2 BEGIN\n    INSERT INTO ExampleSchemaExampleAudit\n    SELECT @ACTION\n         , GETDATE()\n          , ID\n          , SOME_DATA\n          , USER_ID\n          , TMSTAMP\n    FROM DELETED;\n  END ELSE\n  BEGIN\n    INSERT INTO ExampleSchemaExampleAudit\n    SELECT @ACTION\n         , GETDATE()\n         , ID\n         , SOME_DATA\n         , USER_ID\n         , TMSTAMP\n    FROM INSERTED;\n  END\nEND\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#index-information","title":"Index Information","text":"<p>Indexes can be created using the <code>KEY</code> keyword in the SI file:</p> <p>Example SI file: <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n    USER_ID             USERSTAMP\n    TMSTAMP             TIMESTAMP\n\nKEY PKEY PRIMARY\n    ID\n\nKEY INX1\n    SOME_DATA\n\nKEY INX2\n    ID\n    SOME_DATA\n</code></pre> Example output: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER IDENTITY(1,1) NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, USER_ID VARCHAR(50) NOT NULL\n, TMSTAMP DATETIME NOT NULL\n, TIMESTAMP\n, CONSTRAINT PK_ExampleSchema_Example_PKEY PRIMARY KEY (\n    ID\n  )\n)\nGO\n\nCREATE INDEX INX1 ON ExampleSchema.Example\n(\n  SOME_DATA\n)\nGO\n\nCREATE INDEX INX2 ON ExampleSchema.Example\n(\n  ID\n, SOME_DATA\n)\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#unique-constraints","title":"Unique constraints","text":"<p>Unique constraints can be generated by adding the <code>UNIQUE</code> keyword after the name of the index.</p> <p>Example SI file: <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n    USER_ID             USERSTAMP\n    TMSTAMP             TIMESTAMP\n\n\n\nKEY PKEY PRIMARY\n    ID\n\nKEY INX1 UNIQUE\n    SOME_DATA\n</code></pre></p> <p>Example Output: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER IDENTITY(1,1) NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, USER_ID VARCHAR(50) NOT NULL\n, TMSTAMP DATETIME NOT NULL\n, TIMESTAMP\n, CONSTRAINT PK_ExampleSchema_Example_PKEY PRIMARY KEY (\n    ID\n  )\n, CONSTRAINT UK_ExampleSchema_Example_INX1 UNIQUE (\n    SOME_DATA\n  )\n)\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#foreign-keys","title":"Foreign Keys","text":"<p>Foreign Keys can be created on fields to other table fields by using the <code>LINK</code> keyword:</p> <p>Example SI File: <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n    USER_ID             USERSTAMP\n    TMSTAMP             TIMESTAMP\n\n\nLINK Example2.ExampleTable2 SOME_DATA\n</code></pre></p> <p>Example Output: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER IDENTITY(1,1) NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, USER_ID VARCHAR(50) NOT NULL\n, TMSTAMP DATETIME NOT NULL\n, TIMESTAMP\n, CONSTRAINT FK_ExampleSchema_Example_Example2_ExampleTable2_SOME_DATA FOREIGN KEY (\n    SOME_DATA\n  )\n  REFERENCES Example2.ExampleTable2\n)\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#cascades","title":"Cascades","text":"<p>Cascade updates and deletions can be created using the <code>&lt;operation&gt; CASCADE</code> keyword on a link.</p> <p>Example SI File: <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n    USER_ID             USERSTAMP\n    TMSTAMP             TIMESTAMP\n\n\nLINK Example2.ExampleTable2 DELETE UPDATE CASCADE SOME_DATA\n</code></pre></p> <p>Example Output File: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER IDENTITY(1,1) NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, USER_ID VARCHAR(50) NOT NULL\n, TMSTAMP DATETIME NOT NULL\n, TIMESTAMP\n, CONSTRAINT FK_ExampleSchema_Example_Example2_ExampleTable2_SOME_DATA FOREIGN KEY (\n    SOME_DATA\n  )\n  REFERENCES Example2.ExampleTable2\n    ON DELETE CASCADE\n    ON UPDATE CASCADE\n)\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#grants","title":"Grants","text":"<p>Grants can be used to grant actions against the table to username's using the <code>GRANT</code> keyword.</p> <p>Example SI File: <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n    USER_ID             USERSTAMP\n    TMSTAMP             TIMESTAMP\n\nGRANT SELECT INSERT DELETE UPDATE TO FreeTextUserName\n</code></pre></p> <p>Example Output: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER IDENTITY(1,1) NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, USER_ID VARCHAR(50) NOT NULL\n, TMSTAMP DATETIME NOT NULL\n, TIMESTAMP\n)\nGO\n\nGRANT select ON ExampleSchema.Example TO FreeTextUserName\nGO\n\nGRANT insert ON ExampleSchema.Example TO FreeTextUserName\nGO\n\nGRANT delete ON ExampleSchema.Example TO FreeTextUserName\nGO\n\nGRANT update ON ExampleSchema.Example TO FreeTextUserName\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#views","title":"Views","text":"<p>A VIEW can be created using the <code>VIEW</code> keyword. It can also be constrained to a specific user:</p> <p>Example SI File: <pre><code>TABLE Example\n    ID                  SEQUENCE\n    SOME_DATA           CHAR(100)\n    USER_ID             USERSTAMP\n    TMSTAMP             TIMESTAMP\n\n\nVIEW SelectSomeData TO FreeTextUser\nSQLCODE\n    select SOME_DATA from ExampleSchema.ExampleTable\nENDCODE\n</code></pre></p> <p>Example output: <pre><code>CREATE TABLE ExampleSchema.Example\n(\n  ID INTEGER IDENTITY(1,1) NOT NULL\n, SOME_DATA VARCHAR(100) NOT NULL\n, USER_ID VARCHAR(50) NOT NULL\n, TMSTAMP DATETIME NOT NULL\n, TIMESTAMP\n)\nGO\n\nIF OBJECT_ID('ExampleSchema.ExampleGetSomeData','V') IS NOT NULL\n    DROP VIEW ExampleSchema.ExampleGetSomeData\nGO\n\nCREATE VIEW ExampleSchema.ExampleGetSomeData\n(\n) AS\n(\nselect SOME_DATA from ExampleSchema.ExampleTable\n)\nGO\n\nGRANT SELECT ON ExampleSchema.ExampleGetSomeData TO FreeTextUser\nGO\n</code></pre></p>"},{"location":"generators/MSSqlDDL/#general-information","title":"General Information","text":"<p>The generator output will delete the table if the table currently exists: <pre><code>IF OBJECT_ID('Schema.ExampleTable','U') IS NOT NULL\n    DROP TABLE Schema.ExampleTable\nGO\n</code></pre></p>"}]}